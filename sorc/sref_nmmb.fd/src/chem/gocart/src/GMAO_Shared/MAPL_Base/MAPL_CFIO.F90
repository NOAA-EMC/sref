!  $Id: MAPL_CFIO.F90,v 1.84 2009/06/11 15:44:57 ltakacs Exp $

#include "MAPL_Generic.h"

#define MPI_NULL_TAG 99

module MAPL_CFIOMod

!BOP

! !MODULE: MAPL_CFIO --- CF Compliant I/O for ESMF

! !USES:
!
  use ESMF_Mod
  use MAPL_BaseMod
  use MAPL_CommsMod
  use MAPL_ConstantsMod
  use ESMF_CFIOMod  
  use ESMF_CFIOUtilMod
  use ESMF_CFIOFileMod
  use MAPL_IOMod
  use MAPL_HorzTransformMod

  implicit none
  private

! !PUBLIC TYPES:
!
  public MAPL_CFIO

! !PUBLIC MEMBER FUNCTIONS:
!
! MAPL-style names
! ----------------
  public MAPL_CFIOCreate
  public MAPL_CFIOSet
  public MAPL_CFIOOpenWrite
  public MAPL_CFIOCreateWrite
  public MAPL_CFIOClose
  public MAPL_CFIOWrite
  public MAPL_CFIOWriteBundlePost
  public MAPL_CFIOWriteBundleWait
  public MAPL_CFIORead
  public MAPL_CFIODestroy
  public MAPL_GetCurrentFile
  public MAPL_CFIOIsCreated
  public MAPL_CFIOGetFilename

! ESMF-style names
! ----------------
  public ESMF_ioRead     ! another name for MAPL_CFIORead
  public ESMF_ioCreate   ! another name for MAPL_CFIOCreate
  public ESMF_ioWrite    ! another name for MAPL_CFIOWrite
  public ESMF_ioDestroy  ! another name for MAPL_CFIODestroy 
!
!  !DESCRIPTION:  
!
!   \input{TeX/MAPL_CFIODescr.tex}
!

!EOP

! !METHOD OVERLOADING:

!                     MAPL Consistent Naming Convention
!                     ---------------------------------

  interface MAPL_CFIOCreate
     module procedure MAPL_CFIOCreateFromBundle
     module procedure MAPL_CFIOCreateFromState
  end interface

  interface MAPL_CFIOWrite
     module procedure MAPL_CFIOWriteState
     module procedure MAPL_CFIOWriteBundle
  end interface

  interface MAPL_CFIORead
     module procedure MAPL_CFIOReadState
     module procedure MAPL_CFIOReadBundle
     module procedure MAPL_CFIOReadField
     module procedure MAPL_CFIOReadArray3D
     module procedure MAPL_CFIOReadArray2D
  end interface

!                     ESMF Consistent Naming Convention
!                     ---------------------------------

  interface ESMF_ioCreate
     module procedure MAPL_CFIOCreateFromBundle
     module procedure MAPL_CFIOCreateFromState
  end interface

  interface ESMF_ioRead
     module procedure MAPL_CFIOReadState
     module procedure MAPL_CFIOReadBundle
     module procedure MAPL_CFIOReadField
     module procedure MAPL_CFIOReadArray3D
     module procedure MAPL_CFIOReadArray2D
  end interface

  interface ESMF_ioWrite
     module procedure MAPL_CFIOWriteState
     module procedure MAPL_CFIOWriteBundle
  end interface

  interface ESMF_ioDestroy
     module procedure MAPL_CFIODestroy
  end interface

  type Ptr3Arr
     real, pointer              :: Ptr(:,:,:)
  end type Ptr3Arr

  type MAPL_CFIO
     private
     logical                    :: CREATED=.false.
     character(len=ESMF_MAXSTR) :: NAME
     character(len=ESMF_MAXSTR) :: fNAME
     character(len=ESMF_MAXSTR) :: format
     character(len=ESMF_MAXSTR) :: expid
     type(ESMF_CFIO)            :: CFIO
     integer                    :: XYOFFSET
     real                       :: VSCALE
     type(ESMF_TIMEINTERVAL)    :: OFFSET
     type(ESMF_CLOCK)           :: CLOCK
     type(ESMF_FIELDBUNDLE)     :: BUNDLE
     type(ESMF_GridComp)        :: GC
     type(ESMF_Grid)            :: Grid
     integer                    :: Root=MAPL_Root
     integer                    :: PartSize=1
     integer                    :: myPE
     integer                    :: numcores
     integer                    :: comm
     integer                    :: Order=-1
     integer                    :: Nbits=1000
     integer                    :: IM, JM, LM
     integer, pointer           :: VarDims(:)=>null()
     logical                    :: Vinterp
     real                       :: pow=0.0
     character(len=ESMF_MAXSTR) :: Vvar
     character(len=3          ) :: Func
     character(len=ESMF_MAXSTR), &
                        pointer :: VarName(:)=>null()
     integer, pointer           :: Krank(:)=>null()
     real,    pointer           :: levs(:)
     type(MAPL_CommRequest), &
                        pointer :: reqs(:)=>null()
     type(MAPL_HorzTransform)   :: Trans
  end type MAPL_CFIO

  include "mpif.h"

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!BOP
 
! !IROUTINE: MAPL_CFIOCreate --- Creates a MAPL CFIO Object
!
! !IIROUTINE: MAPL_CFIOCreateFromBundle --- Creates MAPL CFIO Object from a Bundle

!
! !INTERFACE:
!
  subroutine MAPL_CFIOCreateFromBundle ( MCFIO, NAME, CLOCK, BUNDLE, OFFSET,      &
                                         RESOLUTION, FREQUENCY, LEVELS, DESCR,    &
                                         XYOFFSET, VCOORD, VUNIT, VSCALE,         &
                                         SOURCE, INSTITUTION, COMMENT, CONTACT,   &
                                         FORMAT, EXPID, DEFLATE, GC,  ORDER, &
                                         NumCores, nbits, RC )
! !ARGUMENTS:
!
    type(MAPL_CFIO),             intent(OUT) :: MCFIO
    character(LEN=*),            intent(IN)  :: NAME
    type(ESMF_FIELDBUNDLE),      intent(INout)  :: BUNDLE
    type(ESMF_CLOCK),            intent(IN)  :: CLOCK
    type(ESMF_TIMEINTERVAL), &
                     optional,   intent(IN)  :: OFFSET
    integer,         optional,   pointer     :: RESOLUTION(:)
    integer,         optional,   intent(IN)  :: FREQUENCY
    real,            optional,   pointer     :: LEVELS(:)
    character(LEN=*),optional,   intent(IN)  :: DESCR
    integer,         optional,   intent(IN)  :: XYOFFSET
    real,            optional,   intent(IN)  :: VSCALE
    integer,         optional,   intent(IN)  :: DEFLATE
    character(len=*),optional,   intent(IN)  :: VUNIT     
    character(len=*),optional,   intent(IN)  :: VCOORD     
    character(len=*),optional,   intent(IN)  :: source
    character(len=*),optional,   intent(IN)  :: institution     
    character(len=*),optional,   intent(IN)  :: comment
    character(len=*),optional,   intent(IN)  :: contact     
    character(len=*),optional,   intent(IN)  :: format
    character(len=*),optional,   intent(IN)  :: EXPID
    type(ESMF_GridComp),optional,intent(IN)  :: GC
    integer,         optional,   intent(IN)  :: Order
    integer,         optional,   intent(IN)  :: Nbits
    integer,         optional,   intent(IN)  :: NumCores
    integer,         optional,   intent(OUT) :: RC

#ifdef ___PROTEX___
!
   !DESCRIPTION:

   Creates a MAPL\_CFIO object from a Bundle. The MAPL\_CFIO objects
   is opaque and its properties can only be set by this method at
   creation. Currently, its properties cannot be queried. The object
   is used only as a handle in write operations. It is not needed for
   reading. 
  
   Its non-optional arguments associate a {\tt NAME}, an ESMF {\tt
   BUNDLE}, and a {\tt CLOCK} with the object. An ESMF TimeInterval
   {\tt OFFSET} is an optional argument that sets an offset between the
   time on the clock when eriting and the time stamp used for the data
   (defaults to no offset).

   The {\tt format} optional argument determines whether the write
   will use the linked self-describing format (SDF) library (HDF or
   netcdf) or write GrADS readable flat files. Currently only the SDF
   library option is supported.

   The remaining (optional) arguments are especialized and used
   primarily to support MAPL\_History, or to provide documentation in
   the form of character strings that will be placed in corresponding
   attributes in the SDF file.

  !REVISION HISTORY:
 
    19Apr2007 Todling  - Added ability to write out ak/bk
                       - Added experiment ID as optional argument

#endif
!
!EOP

! Locals
!-------

    character(len=ESMF_MAXSTR) :: Iam="MAPL_CFIOCreateFromBundle"
    integer                    :: STATUS


    type(ESMF_FIELD)    :: FIELD
    type(ESMF_GRID)     :: ESMFGRID
    type(ESMF_ARRAY)    :: ARRAY
    type(ESMF_DELayout) :: LAYOUT
    type(ESMF_DistGrid) :: DISTGRID
    type(ESMF_TIME)     :: TIME
    type(ESMF_VM)       :: VM

    type(ESMF_CFIOVarInfo), pointer :: vars(:)
    type(ESMF_CFIOGrid),    pointer :: cfiogrid

    real, pointer  :: lats(:,:)
    real, pointer  :: lons(:,:)
    real, pointer  :: lats1d(:)
    real, pointer  :: lons1d(:)
    real, pointer  :: Local(:,:)
    real, pointer  :: lev (:  )
    real, pointer  :: ak  (:  )
    real, pointer  :: bk  (:  )
    real, pointer  :: ulevels(:  )
    real, pointer  :: Ptr3(:,:,:)
    real           :: RANGE(2)
    real           :: xoff, yoff

    real(KIND=8)           :: dlam, dphi
    real(KIND=8), pointer  :: R8D2(:,:)
    real(KIND=8), allocatable :: cornerX(:)
    real(KIND=8), allocatable :: cornerY(:)
    real(KIND=8), allocatable :: centerX(:)
    real(KIND=8), allocatable :: centerY(:)

    integer        :: L, WriteInterval, counts(5), dims(3)
    integer        :: NumVars
    integer        :: IM,JM,LM
    integer        :: gridRank
    integer        :: arrayRank
    integer        :: Comm, nPEs
    integer        :: hours, mins, secs, timeInc
    integer        :: I, J, im0, jm0, II, LL, LT, K, LEN, IMO, JMO, IML, JML
    integer        :: VLOCATION
    integer        :: GROUP, NEWGROUP
    integer        :: L1, L2, Nlots, Extra, MyNumLevs, MyNumVars
    integer        :: Psize, Df
    integer        :: Num2DVars, Num3dVars
    integer        :: Nnodes, Ncores

    integer, allocatable :: Location(:)

    logical        :: HASVLEVS
    logical        :: IS_HDF
    logical        :: Have2D, Have3D, HAVE_center, HAVE_edge
    logical        :: change_resolution

    character(len=ESMF_MAXSTR)  :: VarName, Vunits
    character(len=ESMF_MAXSTR)  :: LongName
    character(len=ESMF_MAXSTR)  :: Units
    character(len=ESMF_MAXSTR)  :: StartTime
    character(len=esmf_maxstr)  :: Usource
    character(len=esmf_maxstr)  :: Uinstitution     
    character(len=esmf_maxstr)  :: Ucomment
    character(len=esmf_maxstr)  :: Ucontact     
    character(len=esmf_maxstr)  :: Utitle
    character(len=esmf_maxstr)  :: GridTypeAttribute

! Begin
!------

    MCFIO%NAME   = NAME 
    MCFIO%CLOCK  = CLOCK
    MCFIO%BUNDLE = BUNDLE

! Number of variables in the bundle
!----------------------------------

    call ESMF_FieldBundleGet (BUNDLE, FieldCount=NumVars,    RC=STATUS)
    VERIFY_(STATUS)

    ASSERT_(NumVars>0)

! Process optionals
!------------------

    if(present(NBITS)) then
       MCFIO%Nbits = NBITS
    else
       MCFIO%nBits = 1000
    end if

    if(present(deflate)) then
       df = deflate
    else
       df = 0
    endif

    if(present(Order)) then
       MCFIO%Order = Order
    else
       MCFIO%Order = -1
    endif

    if(present(source)) then
       Usource = source
    else
       Usource = "unknown"
    endif

    if(present(institution)) then
       Uinstitution = institution
    else
       Uinstitution = "unknown"
    endif

    if(present(comment)) then
       Ucomment = comment
    else
       Ucomment = "unknown"
    endif

    if(present(contact)) then
       Ucontact = contact
    else
       Ucontact = "unknown"
    endif

    if(present(format)) then
       MCFIO%format = format
    else
       MCFIO%format = "SDF"
    endif

    if(present(expid)) then
       MCFIO%expid = expid
    else
       MCFIO%expid = "No_ExpId"
    endif

    if(present(descr )) then
       Utitle  = descr 
    else
       Utitle  = "unknown"
    endif

    if(present(LEVELS)) then
       ulevels => LEVELS
    else
       nullify(ulevels)
    endif

    if(present(GC)) then
       MCFIO%GC   = GC
    else
       MCFIO%GC   = ESMF_GridCompCreate("NULL")
    endif

    if(present(NumCores)) then
       mcfio%Numcores = NumCores
    else
       mcfio%Numcores = 1
    end if

    if(present(VUNIT)) then
       vunits = trim(vunit)
    else
       vunits = ""
    endif

! Get CommBndl, the communicator that is spanned by fields in the bundle
!-----------------------------------------------------------------------

    call ESMF_FieldBundleGet(BUNDLE, 1, FIELD,               RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_FieldGet       (FIELD, grid=ESMFGRID,          RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_GridGet        (ESMFGRID, dimCount=gridRank,   rc=STATUS)
    VERIFY_(STATUS)
    call ESMF_GridGet        (ESMFGRID, distgrid=DISTGRID,   RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_DistGridGet    (DISTGRID, delayout=LAYOUT,     RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_DELayoutGet    (LAYOUT,   vm=VM,               RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_VMGet          (VM, mpiCommunicator=Comm,      RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_VMGet          (VM, localpet=mCFIO%MYPE,       RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_VMGet          (VM, petcount=NPES,             RC=STATUS)
    VERIFY_(STATUS)

! Save the ESMFGrid in the object
!--------------------------------

    mCFIO%comm = comm
    mCFIO%Grid = ESMFGRID

! Vertical interpolation info
!----------------------------

    if(present(Vcoord)) then
       MCFIO%VVAR = adjustl(vcoord)
       MCFIO%Func = MCFIO%Vvar(1:3)
       if    (MCFIO%Func=='log') then
          MCFIO%Vvar = adjustl(MCFIO%Vvar(index(MCFIO%Vvar,'(')+1:index(MCFIO%Vvar,')')-1))
       elseif(MCFIO%Func=='pow') then
          read( MCFIO%Vvar(index(MCFIO%Vvar,',')+1:index(MCFIO%Vvar,')')-1) , *) mCFIO%pow 
          MCFIO%Vvar = adjustl(MCFIO%Vvar(index(MCFIO%Vvar,'(')+1:index(MCFIO%Vvar,',')-1))
       endif
    else
       MCFIO%VVAR = ""
    end if

    if(present(vscale)) then
       MCFIO%Vscale = Vscale
    else
       MCFIO%Vscale = 1.0
    endif

! Determine the rank and vertical Location (Mid or Edge) of Fields within Bundle.
!   Note: If User-Defined ULEVELS is not present, ALL levels are written.
!   In this case, vertical Location must be consistent for ALL variables.
! ---------------------------------------------------------------------------------------

    allocate(MCFIO%VarDims(NumVars), stat=STATUS); VERIFY_(STATUS)
    allocate(MCFIO%VarName(NumVars), stat=STATUS); VERIFY_(STATUS)
    allocate(location     (NumVars), stat=STATUS); VERIFY_(STATUS)

    VARIABLES_1: DO I = 1, NumVars

       call ESMF_FieldBundleGet(BUNDLE, I, FIELD,              RC=STATUS)
       VERIFY_(STATUS)
       call ESMF_FieldGet      (FIELD, NAME= mCFIO%VarName(I), RC=STATUS)
       VERIFY_(STATUS)

       if(mCFIO%VarName(I)==MCFIO%Vvar) then
          MCFIO%VarDims(I) = -1
          LOCATION(i)      = MAPL_VLocationNone
       else
          call ESMF_FieldGet      (FIELD, ARRAY=array,            RC=STATUS)
          VERIFY_(STATUS)
          call ESMF_ArrayGet      (array, rank=arrayRank,         RC=STATUS)
          VERIFY_(STATUS)

          MCFIO%VarDims(I) = arrayRank

          call ESMF_AttributeGet(FIELD, NAME="VLOCATION", VALUE=LOCATION(I), RC=STATUS)
          if ( status /= 0 ) LOCATION(I) = MAPL_VLocationNone
       endif

    end do VARIABLES_1

! Sizes of global grid in the bundle. Sizes in the SDF may be different.
!----------------------------------------------------------------------

    call MAPL_GridGet( MCFIO%GRID, globalCellCountPerDim=COUNTS,  &
                       localCellCountPerDim=DIMS,     RC=STATUS)
    VERIFY_(STATUS)

    IML = DIMS(1)
    JML = DIMS(2)

    IM = COUNTS(1)
    JM = COUNTS(2)

    if     ( associated(ULEVELS)  ) then
       LM = size(ULEVELS)
    else if( all(MCFIO%VarDims==2)) then
       LM = 1
    else
       LM = COUNTS(3)
    endif

    mCFIO%LM   = LM

! Check on proper levels
!-----------------------

    if (.not.associated(ULEVELS) ) then
       HAVE_center = any(LOCATION==MAPL_VLocationCenter)
       HAVE_edge   = any(LOCATION==MAPL_VLocationEdge  )
       if(HAVE_center .and.  HAVE_edge) then
          print *, 'ERROR: Mixed Vlocation in CFIO not allowed unless LEVELS id specified'
          ASSERT_(.false.)
       endif
    end if

! Allocate request arrays for non-blocking gathers of bundle variables
!  Each 2D variable and each level of each 3D variable needs a request
!---------------------------------------------------------------------

    Num2DVars = count(MCFIO%VarDims==2)
    Num3DVars = count(MCFIO%VarDims==3)

    Have2D    = Num2DVars > 0
    Have3D    = Num3DVars > 0

    ASSERT_(HAVE2D .or. HAVE3D)

    LT        = Num2DVars + Num3DVars*LM

    allocate( MCFIO%reqs (LT),stat=STATUS)
    VERIFY_(STATUS)
    allocate( MCFIO%Krank(LT),stat=STATUS)
    VERIFY_(STATUS)


! Horizontal dimensions of output fields
!---------------------------------------

    IMO = IM
    JMO = JM

    if (present(RESOLUTION)) then
       if (associated(RESOLUTION)) then
          IMO = resolution(1)
          JMO = resolution(2)
       endif
    endif

    MCFIO%IM = IMO
    MCFIO%JM = JMO

    allocate(LONS1D(IMO), STAT=status)
    VERIFY_(status)
    allocate(LATS1D(JMO), STAT=status)
    VERIFY_(status)

! Process horizontal resolution change
!-------------------------------------

    TRANSFORM: if (IM /= IMO .or. JM /= JMO) then
       if(present(xyoffset)) then
          select case(xyoffset)
          case(0)
             xoff = 0.0
             yoff = 0.0
          case(1)
             xoff = 0.5
             yoff = 0.0
          case(2)
             xoff = 0.0
             yoff = 0.5
          case(3)
             xoff = 0.5
             yoff = 0.5
          case default
             ASSERT_(.false.)
          end select
          mcfio%xyoffset = xyoffset
       else
          xoff = 0.0
          yoff = 0.0
          mcfio%xyoffset = 0
       endif

       dlam = 2.0*MAPL_PI/IMO

       if(yoff>0) then
          dphi = MAPL_PI/(JMO  )
       else
          dphi = MAPL_PI/(JMO-1)
       end if

       if(mcfio%xyoffset == 0) then

          allocate(cornerX(IMO+1),cornerY(JMO+1), stat=status)
          VERIFY_(STATUS)
          allocate(centerX(IMO)  ,centerY(JMO)  , stat=status)
          VERIFY_(STATUS)

          cornerX(1) = -MAPL_PI - dlam/2
          do i = 1,IMO
             cornerX(i+1) = cornerX(i) + dlam
          enddo
       
          cornerY(1) = -MAPL_PI/2 - dphi/2
          do j = 1,JMO
             cornerY(j+1) = cornerY(j) + dphi
          enddo

          do i=1,IMO
             centerX(i) = 0.5d0*(cornerX(I)+cornerX(I+1))
          enddo

          do j=1,JMO
             centerY(j) = 0.5d0*(cornerY(J)+cornerY(J+1))
          enddo

          lons1d = centerX*(180/MAPL_PI)
          lats1d = centerY*(180/MAPL_PI)

          deallocate(cornerx,cornery)
          deallocate(centerx,centery)
       else
          do i=1,IMO
             lons1d(i) = -MAPL_PI     + (i-1+xoff)*dlam
          enddo

          do j=1,JMO
             lats1d(j) = -MAPL_PI/2.0 + (j-1+yoff)*dphi
          enddo
          lats1d = lats1d*(180/MAPL_PI)
          lons1d = lons1d*(180/MAPL_PI)
       endif


! Cube2Latlon remapping requires lons range from 0:360
!------------------------------------------------------

       call ESMF_AttributeGet(ESMFGRID, name="GridType", value=GridTypeAttribute, rc=STATUS)
       if (STATUS /= ESMF_SUCCESS) then
          GridTypeAttribute = 'UNKNOWN'
       endif

       if (trim(GridTypeAttribute) == 'Cubed-Sphere') then
          lons1d = lons1d + 180.0
       endif       
       
! If order of transform was not specified, do binning for coarser,
!   and bilinear for finer.
!------------------------------------------------------------------

       if     (mCFIO%order<0) then
          if (IMO <  IM .or. JMO < JM) then
             mCFIO%order=0
          else
             mCFIO%order=1
          end if
       end if

! Create the transform at all pes, whether they need it or not.
!--------------------------------------------------------------

       call MAPL_HorzTransformCreate (mCFIO%Trans, IM, JM, IMO, JMO, &
                    GridTypeIn=GridTypeAttribute,                    &
                    XYOFFSET=MCFIO%XYOFFSET, order=mCFIO%order, rc=STATUS)
       VERIFY_(STATUS)

    else

! Arrays of lats and lons from esmfgrid
!--------------------------------------

       allocate(LONS (IM ,JM ),STAT=STATUS); VERIFY_(STATUS)
       allocate(LATS (IM ,JM ),STAT=STATUS); VERIFY_(STATUS)
       allocate(LOCAL(IML,JML),STAT=STATUS); VERIFY_(STATUS) 

       call ESMF_GridGetCoord(esmfgrid, localDE=0, coordDim=1, &
            staggerloc=ESMF_STAGGERLOC_CENTER, &
            fptr=R8D2, doCopy=ESMF_DATA_REF, rc=status)
       VERIFY_(STATUS)

       LOCAL = R8D2*(180/MAPL_PI)
       call ArrayGather(LOCAL, LONS, ESMFGRID, RC=STATUS)
       VERIFY_(STATUS) 

       call ESMF_GridGetCoord(esmfgrid, localDE=0, coordDim=2, &
            staggerloc=ESMF_STAGGERLOC_CENTER, &
            fptr=R8D2, doCopy=ESMF_DATA_REF, rc=status)
       VERIFY_(STATUS) 

       LOCAL = R8D2*(180/MAPL_PI)
       call ArrayGather(LOCAL, LATS, ESMFGRID, RC=STATUS)
       VERIFY_(STATUS)

       call MAPL_CommsBcast (layout, lons, size(lons), 0, rc=status)
       VERIFY_(STATUS)
       call MAPL_CommsBcast (layout, lats, size(lats), 0, rc=status)
       VERIFY_(STATUS)

       LONS1D = LONS(:,1)
       LATS1D = LATS(1,:)

       DEALLOCATE(LONS)
       DEALLOCATE(LATS)

    endif TRANSFORM

! Create the CFIO grid and populate it
!-------------------------------------

    allocate(CFIOGRID)

    CFIOGRID = ESMF_CFIOGridCreate(gName=trim(NAME)//"Grid", RC=STATUS)
    VERIFY_(STATUS)

! Horizontal grid info
!---------------------

    call ESMF_CFIOGridSet(CFIOGRID, IM=IMO, JM=JMO,          RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_CFIOGridSet(CFIOGRID, LON=LONS1D, LAT=LATS1D,  RC=STATUS)
    VERIFY_(STATUS)

    deallocate(LONS1D)
    deallocate(LATS1D)

! Vertical grid info
!--------------------

    VERTGRID: if(HAVE3D) THEN
       allocate(LEV(LM))
       
       if (associated(ULEVELS)) then
          LEV = ULEVELS
       else
          LEV = (/(L, L=1,LM)/)
       end if

       mCFIO%Vinterp = MCFIO%Vvar/=""

       if(mCFIO%Vinterp) then
          allocate(mCFIO%levs(size(lev)), stat=status)
          VERIFY_(STATUS)
          if    (mCFIO%Func=='log') then
             mCFIO%levs = log(lev* MCFIO%vscale)
          elseif(mCFIO%Func=='pow') then
             mCFIO%levs = (lev* MCFIO%vscale)**mCFIO%pow
          else
             mCFIO%levs = lev* MCFIO%vscale
          end if

          if( trim(vunits).eq."" ) then
             call ESMF_AttributeGet(FIELD, NAME="UNITS", VALUE=units,         RC=STATUS)
             VERIFY_(STATUS)
             call ESMF_CFIOGridSet(cfiogrid, levUnit=trim(units),             RC=STATUS)
             VERIFY_(STATUS)
          else
             call ESMF_CFIOGridSet(cfiogrid, levUnit=trim(vunits),            RC=STATUS)
             VERIFY_(STATUS)
          endif
          call ESMF_CFIOGridSet(cfiogrid, standardName =trim(MCFIO%Vvar)//'_level', RC=STATUS)
          VERIFY_(STATUS)
          call ESMF_CFIOGridSet(cfiogrid, coordinate   =trim(MCFIO%Vvar),           RC=STATUS)
          VERIFY_(STATUS)
       else
          call ESMF_CFIOGridSet(cfiogrid, levUnit      ='layer',              RC=STATUS)
          VERIFY_(STATUS)
          call ESMF_CFIOGridSet(cfiogrid, standardName ='model_layers',       RC=STATUS)
          VERIFY_(STATUS)
          call ESMF_CFIOGridSet(cfiogrid, coordinate   ='eta',                RC=STATUS)
          VERIFY_(STATUS)
       end if

       call ESMF_CFIOGridSet(cfiogrid, lev=lev,  RC=STATUS)
       VERIFY_(STATUS)

       deallocate(LEV)

    else

       call ESMF_CFIOGridSet(cfiogrid, levUnit      ='none',         RC=STATUS)
       VERIFY_(STATUS)
       call ESMF_CFIOGridSet(cfiogrid, standardName ='2d_fields',    RC=STATUS)
       VERIFY_(STATUS)
       call ESMF_CFIOGridSet(cfiogrid, coordinate   ='N/A',          RC=STATUS)
       VERIFY_(STATUS)

    end if VERTGRID

! Create variable objects
!------------------------

    allocate(vars(Num2DVars+Num3dVars), stat=status)
    VERIFY_(STATUS)

! Disable range checking
!-----------------------

    RANGE(2) = MAPL_Undef
    RANGE(1) = MAPL_Undef

    K = 0

    VARIABLES_2: do L=1,NumVars

       if(mCFIO%VarDims(L)<1) cycle

       K = K + 1

       call ESMF_FieldBundleGet(BUNDLE, L, FIELD,                       RC=STATUS)
       VERIFY_(STATUS)
       call ESMF_AttributeGet  (FIELD, NAME="LONG_NAME",VALUE=LongName, RC=STATUS)
       if ( status /= 0 ) LongName = mCFIO%VarName(L)
       call ESMF_AttributeGet  (FIELD, NAME="UNITS"    ,VALUE=Units,    RC=STATUS)
       if ( status /= 0 ) Units = 'unknown'

       VARS(K) = ESMF_CFIOVarInfoCreate(vName=trim(mCFIO%VarName(L)),   RC=STATUS)
       VERIFY_(STATUS)

       call ESMF_CFIOVarInfoSet(VARS(K),           &
            vName        = mCFIO%VarName(L),       &
            vTitle       = LongName,               &
            grid         = cfioGRID,               &
            amiss        = MAPL_Undef,             &
            scaleFactor  = 1.,                     &
            addOffSet    = 0.,                     &
            standardName = LongName,               &
            twoDimVar    = MCFIO%VarDims(L)==2,    &
            validRange   = RANGE,                  &
            vUnits       = UNITS,                  &
                                         RC=STATUS )
       VERIFY_(STATUS)

    end do VARIABLES_2

! Get time info from the clock. Note the optional offset
!-------------------------------------------------------

    call ESMF_ClockGet(CLOCK, CurrTime =TIME, RC=STATUS)
    VERIFY_(STATUS)

    if(present(OFFSET)) then
       TIME = TIME - OFFSET
       MCFIO%OFFSET = OFFSET
    else
      call ESMF_TimeIntervalSet( MCFIO%OFFSET, S=0, rc=status )
      VERIFY_(STATUS)
    endif

    call ESMF_TimeGet (TIME,  timeString=StartTime, RC=STATUS)
    VERIFY_(STATUS)

! Create CFIO object
!-------------------

    MCFIO%cfio =  ESMF_CFIOCreate(cfioObjName=trim(Name))

! Set Internal MetaCode Writing interval. Default of 6 hours. If set to 0
!  it is reset to 6 hours.Currently CFIO and GFIO expect timeIncrement to be 
!  in HHMMSS format, this imposes severe limitations to the frequency of the output:
!  no writes should be done less frequently than once every 4 days (99 hours)
! ------------------------------------------------------------------------------

    if (present(FREQUENCY)) then
       ASSERT_(FREQUENCY <= 4*86400)
       if (frequency == 0 ) then
          writeInterval = 21600
       else
          writeInterval = FREQUENCY
       endif
    else
       writeInterval = 21600
    end if

    hours         = writeInterval/3600
    writeInterval = writeInterval-3600*hours
             mins = writeInterval/60
             secs = writeInterval-60*mins

    timeinc = 10000*hours + 100*mins + secs

! Set global attributes
!----------------------

    call ESMF_CFIOSet(MCFIO%CFIO,                                 &
         varObjs     = VARS,                                      &
         grid        = cfioGRID,                                  &
         format      = MCFIO%Format,                              &
         expid       = MCFIO%ExpId,                               &
         TimeString  = trim(StartTime),                           &
         timeInc     = timeInc,                                   &
         title       = trim(Utitle),                              &
         source      = Usource,                                   &
         history     = 'File written by MAPL_CFIO',               &
         institution = Uinstitution,                              &
         convention  = "COARDS",                                  &
         contact     = Ucontact,                                  &
         references  = "see MAPL documentation",                  &
         comment     = Ucomment,                                  & 
         prec        = 0,                                         &
         deflate     = df,                                        &
         RC=STATUS )
    VERIFY_(STATUS)

! Create AK/BKs
! -------------

    if(HAVE3D) then
       allocate ( ak(lm+1), bk(lm+1) )

       call ESMF_AttributeGet(ESMFGRID, 'ak', lm+1, ak, rc=STATUS)
       if (STATUS==ESMF_SUCCESS) &
            call ESMF_CFIOSet(MCFIO%cfio, attRealName='ak', attReal=ak )

       call ESMF_AttributeGet(ESMFGRID, 'bk', lm+1, bk, rc=STATUS)
       if (STATUS==ESMF_SUCCESS) &
            call ESMF_CFIOSet(MCFIO%cfio, attRealName='bk', attReal=bk )

       deallocate ( ak, bk )
    endif

! All Done
!---------

    MCFIO%CREATED = .true.

    deallocate(vars)
    deallocate(cfiogrid)

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_CFIOCreateFromBundle


  subroutine MAPL_CFIOCreatewrite ( MCFIO, nsteps, RC )

    type(MAPL_CFIO),           intent(INOUT) :: MCFIO
    integer,         optional, intent(   IN) :: nsteps
    integer,         optional, intent(  OUT) :: RC

    type(ESMF_Time)                :: CurrTime
    character(len=ESMF_MAXSTR)     :: StartTime

    character(len=ESMF_MAXSTR)     :: Iam="MAPL_CFIOCreatewrite"
    integer                        :: STATUS


    if(present(nsteps)) then
       call ESMF_CFIOSet(MCFIO%CFIO, nsteps=nsteps, RC=STATUS)
       VERIFY_(STATUS)
    else
       call ESMF_CFIOSet(MCFIO%CFIO, nsteps=1, RC=STATUS)
       VERIFY_(STATUS)
    endif 

! Get time info from the clock. Note the optional offset
!-------------------------------------------------------
    
    call ESMF_ClockGet(mCFIO%CLOCK, CurrTime=CurrTime, RC=STATUS)
    VERIFY_(STATUS)

    CurrTime = CurrTime - mCFIO%OFFSET

    call ESMF_TimeGet (CurrTime,  timeString=StartTime, RC=STATUS)
    VERIFY_(STATUS)

    call ESMF_CFIOSet(MCFIO%CFIO, TimeString=trim(StartTime), RC=STATUS)
    VERIFY_(STATUS)

    call ESMF_CFIOSet(MCFIO%CFIO, fName=trim(mCFIO%fName),     RC=STATUS)
    VERIFY_(STATUS)

! Create FILE from the root of the partition working on this bundle.
!------------------------------------------------------------------

    AMROOT: if (mCFIO%MYPE==MCFIO%Root) then

       call ESMF_CFIOFileCreate(MCFIO%CFIO, format=MCFIO%format, &
                                expid=MCFIO%EXPID,      RC=STATUS)
       VERIFY_(STATUS)
!      print *, ' Created CFIO File: ', trim(mCFIO%fName)

    end if AMROOT

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_CFIOCreateWrite



  subroutine MAPL_CFIOOpenWrite ( MCFIO, RC )

    type(MAPL_CFIO),           intent(INOUT) :: MCFIO
    integer,         optional, intent(  OUT) :: RC

    character(len=ESMF_MAXSTR)     :: Iam="MAPL_CFIOOpenWrite"
    integer                        :: STATUS


! Open the file for writing only at the root process
!---------------------------------------------------

    AMROOT: if (mCFIO%MYPE==MCFIO%Root) then
       call ESMF_CFIOFileOpen(MCFIO%CFIO, fmode=0, RC=STATUS)
       VERIFY_(STATUS)
!      print *, ' Opened CFIO File: ', trim(mCFIO%fName)
    end if AMROOT

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_CFIOOpenWrite

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!BOP

! !IIROUTINE: MAPL_CFIOCreateFromState --- Creates MAPL CFIO Object from a State

! !INTERFACE:
!
  subroutine MAPL_CFIOCreateFromState ( MCFIO, NAME, CLOCK, STATE, OFFSET,  &
                                        RESOLUTION, LEVELS, DESCR, BUNDLE, &
                                        XYOFFSET, VCOORD, VUNIT, VSCALE,   &
                                        SOURCE, INSTITUTION, COMMENT, CONTACT, &
                                        FORMAT, EXPID, DEFLATE, GC,  ORDER, &
                                          NumCores, nbits,           RC )

!
! !ARGUMENTS:
!
    type(MAPL_CFIO),             intent(OUT) :: MCFIO
    character(LEN=*),            intent(IN)  :: NAME
    type(ESMF_State),            intent(INout)  :: STATE
    type(ESMF_Clock),            intent(IN)  :: CLOCK
    type(ESMF_FieldBundle), optional,  pointer    :: BUNDLE
    type(ESMF_TimeInterval), &
                     optional,   intent(IN)  :: OFFSET
    integer,         optional,   pointer     :: RESOLUTION(:)
    real,            optional,   pointer     :: LEVELS(:)
    character(LEN=*),optional,   intent(IN)  :: DESCR
    real,            optional,   intent(IN)  :: VSCALE
    character(len=*),optional,   intent(IN)  :: VUNIT     
    character(len=*),optional,   intent(IN)  :: VCOORD     
    integer,         optional,   intent(IN)  :: XYOFFSET
    character(len=*),optional,   intent(IN)  :: source
    character(len=*),optional,   intent(IN)  :: institution     
    character(len=*),optional,   intent(IN)  :: comment
    character(len=*),optional,   intent(IN)  :: contact     
    character(len=*),optional,   intent(IN)  :: format
    character(len=*),optional,   intent(IN)  :: EXPID
    integer,         optional,   intent(IN)  :: DEFLATE
    type(ESMF_GridComp),optional,intent(IN)  :: GC
    integer,         optional,   intent(IN)  :: Order
    integer,         optional,   intent(IN)  :: Nbits
    integer,         optional,   intent(IN)  :: NumCores
    integer, optional,           intent(OUT) :: RC
!
#ifdef ___PROTEX___

    !DESCRIPTION: 

     Creates a MAPL\_CFIO object from a State. States are written by
     ``serializing'' all Fields in them, whether they are directly in
     the State or are contained within a hierarchy of embedded Bundles
     and States, into a single Bundle.

     The Method optionally returns a pointer to the serialized ESMF
     Bundle, but this is not needed for MAPL\_Write
     operations. Otherwise arguments are the same as for
     CreateFromBundle.

   Its non-optional arguments associate a {\tt NAME}, an ESMF {\tt
   BUNDLE}, and a {\tt CLOCK} with the object. An ESMF TimeInterval
   {\tt OFFSET} is an optional argument that sets an offset between the
   time on the clock when eriting and the time stamp used for the data
   (defaults to no offset).

   The {\tt format} optional argument determines whether the write
   will use the linked self-describing format (SDF) library (HDF or
   netcdf) or write GrADS readable flat files. Currently only the SDF
   library option is supported.

   The remaining (optional) arguments are especialized and used
   primarily to support MAPL\_History, or to provide documentation in
   the form of character strings that will be placed in corresponding
   attributes in the SDF file.

  !REVISION HISTORY:
 
   12Jun2007 Todling  Added EXPID as opt argument

#endif

!EOP

    character(len=ESMF_MAXSTR)     :: Iam="MAPL_CFIOCreateFromState"
    integer                        :: STATUS

! Locals

    type(ESMF_FieldBundle), target :: tBUNDLE

!   Create an empty bundle
!   ----------------------

    tBUNDLE = ESMF_FieldBundleCreate ( name=Iam, rc=STATUS )
    VERIFY_(STATUS)
    
!   Serialize the state
!   -------------------

    call ESMFL_BundleAddState_ ( tBUNDLE, STATE, rc=STATUS, VALIDATE=.true. )
    VERIFY_(STATUS)

!   Create the mapl_CFIO object
!   ----------------------

    call MAPL_CFIOCreateFromBundle ( MCFIO, NAME, CLOCK, tBUNDLE,        &
                                     OFFSET = OFFSET,                    & 
                                     RESOLUTION=RESOLUTION,              &
                                     LEVELS=LEVELS,                      &
                                     DESCR=DESCR,                        &
                                     XYOFFSET= XYOFFSET,                 &
                                     VCOORD  = VCOORD,                   &
                                     VUNIT   = VUNIT,                    &
                                     VSCALE  = VSCALE,                   &
                                     SOURCE  = SOURCE,                   &
                                     INSTITUTION = INSTITUTION,          &
                                     COMMENT = COMMENT,                  &
                                     CONTACT = CONTACT,                  &
                                     FORMAT  = FORMAT,                   &
                                     EXPID   = EXPID,                    &
                                     DEFLATE = DEFLATE,                  &
                                     GC      = GC,                       &
                                     ORDER   = ORDER,                    &
                                     NumCores= NUMCORES,                 &
                                     nbits   = NBITS,                    &
                                                               RC=STATUS )
    VERIFY_(STATUS)

    if ( present(BUNDLE) ) then
         BUNDLE => tBUNDLE
    end if

    RETURN_(ESMF_SUCCESS)

  end subroutine MAPL_CFIOCreateFromState
    

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!BOP

! !IROUTINE: MAPL_CFIOWrite --- Writing Methods
! !IIROUTINE: MAPL_CFIOWriteBundle --- Writes an ESMF Bundle 

! !INTERFACE:
!
  subroutine MAPL_CFIOWriteBundlePost( MCFIO, RC )
!
! !ARGUMENTS:
!
    type(MAPL_CFIO  ),               intent(INOUT) :: MCFIO
    integer,               optional, intent(  OUT) :: RC
!
#ifdef ___PROTEX___

 !DESCRIPTION:  

       Writes an ESMF Bundle to a File. Only the MAPL\_CFIO object is
       a required argument as pointers to the actual data to be
       written is recorded in it during creation.

       {\tt CLOCK, BUNDLE} can be used to override the choice
       made at creation, but this is of dubious value, particularly
       for {\tt BUNDLE} since it must be excatly conformant with the
       creation {\tt BUNDLE}. {\tt NBITS} if the number of bits of 
       the mantissa to retain. This is used to write files with degraded
       precision, which can then be compressed with standard utilities.
       The default is no degradation of precision.

       {\bf A note about compression.} NetCDF-4, HDF-4 and HDF-5 all
       support transparent internal GZIP compression of the data being
       written. However, very little is gained by compressing float
       point fields from earth system models. Compression yields can
       be greatly increased by setting to zero bits in the mantissa of float
       numbers. On average 50\% compression can be achieved, while
       preserving a meaningful accuracy in the fields. Unlike
       classical CF compression by means of {\tt scale\_factor} and
       {\tt add\_offset} attributes, internal GZIP compression
       requires no special handling by the users of the data. In fact,
       they do not even need to know that the data is compressed! At this
       point, MAPL\_CFIO does not activate this GZIP compression
       feature in the files being written, but the resulting precision 
       degredaded files can be compressed offline with the HDF-4 
       {\tt hrepack} utility.

#endif

!EOP

    character(len=*), parameter:: Iam="MAPL_CFIOWriteBundlePost"
    integer                    :: status

    type(ESMF_FIELD)           :: FIELD
    integer                    :: L, K, k0, II, LL, LM
    integer                    :: NN, Nnodes
    real,             pointer  :: Ptr2(:,:), Ptr3(:,:,:)
    real, target, allocatable  :: Ple3d(:,:,:)
    real,         allocatable  :: Pl3d(:,:,:)
    real,             pointer  :: layer(:,:)
    

!                              ---

    ASSERT_(MCFIO%CREATED)

!  Set centers and edges of interpolating field
!----------------------------------------------

    if(mCFIO%Vinterp) then
       call ESMF_FieldBundleGet(mCFIO%bundle, Name=mCFIO%Vvar, Field=Field,  RC=STATUS)
       VERIFY_(STATUS)

       nullify (ptr3)
       call ESMF_FieldGet(Field, localDE=0, farray=Ptr3, rc=status)
       VERIFY_(STATUS)

       ! The interpolating variable has to be a zero-based edge variable
       !----------------------------------------------------------------

       ASSERT_(lbound(PTR3,3)==0)

       allocate( ple3D(size(Ptr3,1),size(Ptr3,2),size(Ptr3,3)  ), stat=status)
       VERIFY_(STATUS)
       allocate(  pl3D(size(Ptr3,1),size(Ptr3,2),size(Ptr3,3)-1), stat=status)
       VERIFY_(STATUS)
       allocate( LAYER(size(Ptr3,1),size(Ptr3,2) ), stat=status)
       VERIFY_(STATUS)

       if    (mCFIO%Func=='log') then
          ple3D = log(Ptr3)
          pl3D  = log( 0.5*(Ptr3(:,:,1:)+Ptr3(:,:,0:ubound(Ptr3,3)-1)) )
       elseif(mCFIO%Func=='pow') then
          ple3D = Ptr3**mCFIO%pow
          pl3D  =    ( 0.5*(Ptr3(:,:,1:)+Ptr3(:,:,0:ubound(Ptr3,3)-1)) )**mCFIO%pow
       else
          ple3D = Ptr3
          pl3D  =    ( 0.5*(Ptr3(:,:,1:)+Ptr3(:,:,0:ubound(Ptr3,3)-1)) )
       end if
    end if

! Counter for slices
!-------------------


! Layers will be collected to different processors in round-robin fashion
!    among the PEs in the partition.
!------------------------------------------------------------------------

    Nnodes = (MCFIO%PartSize-1)/MCFIO%Numcores + 1

    do L=1,size(MCFIO%Krank)
       II             = mod((L-1)/Nnodes,MCFIO%Numcores)
       LL             = mod((L-1)*MCFIO%Numcores + II,MCFIO%PartSize)
       MCFIO%Krank(L) = MCFIO%ROOT + mod(LL,MCFIO%PartSize)
    enddo

! Cycle through all variables posting receives.
!----------------------------------------------

    nn = 0

    POSTRECV: do L=1, size(MCFIO%VarDims)
       if    (mCFIO%VarDims(L)==2) then ! Rank == 2
          LM = 1
       elseif(MCFIO%VarDims(L)==3) then ! Rank == 3
          LM = MCFIO%LM
       else
          LM = 0
       endif

       do K=1,LM
          nn    = nn + 1
          call MAPL_CreateRequest(MCFIO%GRID, MCFIO%Krank(nn), MCFIO%reqs(nn), RC=STATUS)
          VERIFY_(STATUS)
       enddo
    end do POSTRECV

! Cycle through all variables posting sends.
!-------------------------------------------

    nn = 0

    VARIABLES: do L=1, size(MCFIO%VarDims)

       call ESMF_FieldBundleGet(MCFIO%BUNDLE, L, FIELD,                  RC=STATUS)
       VERIFY_(STATUS)

! We treat only fields with rank 2 (horizontal 2D) and 
!  rank 3 (first 2 dimension are horz, third is vert).
!--------------------------------------------------------

       RANK: if (MCFIO%VarDims(L)==2) then ! Rank == 2

          nn    = nn + 1
          ptr2  =>null()

          call ESMF_FieldGet      (FIELD, localDE=0, farray=PTR2, RC=STATUS)
          VERIFY_(STATUS)
          call MAPL_ArrayIGather  (Ptr2, MCFIO%reqs(NN),          RC=STATUS)
          VERIFY_(STATUS)

       elseif(MCFIO%VarDims(L)==3) then ! Rank == 3

          ptr3 =>null()

          call ESMF_FieldGet      (FIELD, localDE=0, farray=PTR3, RC=STATUS)
          VERIFY_(STATUS)

          K0  = lbound(PTR3,3) - 1

! For each level, interpolate vertically and post gather
!-------------------------------------------------------

          LAYERS: do K=1,MCFIO%LM
             VINTERP: if(mCFIO%Vinterp) then
                call VertInterp(LAYER, PTR3, MCFIO%LEVS(K), ple3d, pl3d, rc=status)
                VERIFY_(STATUS)
             else
                LAYER => PTR3(:,:,K+K0)
             end if VINTERP

             nn    = nn + 1

             call MAPL_ArrayIGather(LAYER, MCFIO%reqs(nn), rc=status)
             VERIFY_(STATUS)
          enddo LAYERS

       end if RANK

    end do VARIABLES



!   if(mCFIO%myPE==mCFIO%Root) then
!      print *, ' Posted to File: ', trim(mCFIO%fName)
!   endif


    if(mCFIO%Vinterp) then
       deallocate( ple3D, stat=status)
       VERIFY_(STATUS)
       deallocate( pl3D , stat=status)
       VERIFY_(STATUS)
       deallocate( Layer, stat=status)
       VERIFY_(STATUS)
    end if

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_CFIOWriteBundlePost

  subroutine MAPL_CFIOWriteBundleWait( MCFIO, CLOCK, RC )

    type(MAPL_CFIO  ),                 intent(INOUT) :: MCFIO
    type(ESMF_CLOCK),                  intent(IN   ) :: CLOCK
    integer,                optional,  intent(  OUT) :: RC

! Locals
!-------

    character(len=*), parameter:: Iam="MAPL_CFIOWriteBundleWait"
    integer                    :: status

    integer                    :: L, K, NN, Lout
    logical                    :: AmRoot, MyGlobal
    type(ESMF_TIME )           :: TIME
    character(len=ESMF_MAXSTR) :: DATE
    real,          pointer     :: Gptr3Out(:,:,:)
    real,          pointer     :: Gptr2Out(:,:  )
    real,          pointer     :: PtrGlob (:,:  )


! Space for global arrays is allocated everywhere, even if not used.
!------------------------------------------------------------------

    ASSERT_(MCFIO%CREATED)

! Set the time at which we will be writing from the clock
!--------------------------------------------------------

    call ESMF_ClockGet       (CLOCK,     CurrTime =TIME,     RC=STATUS)
    VERIFY_(STATUS)

    TIME = TIME - MCFIO%OFFSET

    call ESMF_TimeGet        (TIME,     timeString=DATE,     RC=STATUS)
    VERIFY_(STATUS)

! Allocate global 2d and 3d arrays at the writing resolution
!  Note that everybody allocated these.
!-----------------------------------------------------------

    allocate(Gptr3Out(Mcfio%IM, Mcfio%JM,1), stat=STATUS)
    VERIFY_(STATUS)

    Gptr2Out => Gptr3Out(:,:,1)

    Lout = Mcfio%IM*Mcfio%JM

    nn   = 0

    AmRoot = mCFIO%myPE==mCFIO%Root

    VARIABLES: do L=1,size(MCFIO%VarDims)

       RANK: if (MCFIO%VarDims(L)==2) then
          nn       = nn + 1
          MyGlobal = mCFIO%Krank(nn) == MCFIO%MYPE

! Wait on request for slice nn
!-----------------------------

          call MAPL_CollectiveWait(MCFIO%reqs(nn), Glob2=PtrGlob, rc=status)
          VERIFY_(STATUS)

! Horizontal Interpolation and Shaving on PEs with global data
! ------------------------------------------------------------

          if( MyGlobal ) &
               call TransShaveAndSend(PtrGlob,Gptr2Out)

          IAMVARROOT: if(AmRoot) then
             if( .not.MyGlobal ) then
                call MPI_Recv(Gptr2Out,size(Gptr2Out),MPI_REAL, mCFIO%Krank(nn), &
                              MPI_ANY_TAG,  mCFIO%comm, MPI_STATUS_IGNORE, STATUS)
                VERIFY_(STATUS)
             end if

             call ESMF_CFIOVarWrite(MCFIO%CFIO, trim(MCFIO%VARNAME(L)), &
                                    Gptr2Out, timeString=DATE,  RC=STATUS)
             VERIFY_(STATUS)
          end if IAMVARROOT

       elseif (MCFIO%VarDims(L)==3) then

! Everyone waits, processes their layer, and sends it to root.
!   Root write it out.
!-------------------------------------------------------------

          LEVELS: do k=1,MCFIO%lm
             nn       = nn + 1
             MyGlobal = MCFIO%Krank(nn) == MCFIO%MYPE

             call MAPL_CollectiveWait(MCFIO%reqs(nn), Glob2=PtrGlob, rc=status)
             VERIFY_(STATUS)


             if( MyGlobal ) &
                  call TransShaveAndSend(PtrGlob,Gptr2Out)

             IAMLEVROOT: if(AmRoot) then
                if( .not.MyGlobal ) then
                   call MPI_Recv(Gptr2Out, size(Gptr2Out), MPI_REAL, mCFIO%Krank(nn), &
                                 MPI_ANY_TAG,  mCFIO%comm, MPI_STATUS_IGNORE,   STATUS)
                   VERIFY_(STATUS)
                end if

                call ESMF_CFIOVarWrite(MCFIO%CFIO, trim(MCFIO%VARNAME(L)), &
                                       Gptr3Out, kbeg=K, kount=1,          &
                                       timeString=DATE,           RC=STATUS)
                VERIFY_(STATUS)
             end if IAMLEVROOT
          end do LEVELS
       endif RANK

    end do VARIABLES

    if(AmRoot) then
       print *, ' Wrote to File: ', trim(mCFIO%fName)
    endif

! Clean-up
!---------

    deallocate(Gptr3Out, stat=STATUS); VERIFY_(STATUS)

    RETURN_(ESMF_SUCCESS)

  contains
    
    subroutine TransShaveAndSend(Gin,Gout)
      real, pointer :: Gin (:,:)
      real, pointer :: Gout(:,:)

      if (MAPL_HorzTransformIsCreated(mCFIO%Trans)) then
         call MAPL_HorzTransformRun(mCFIO%Trans, Gin, Gout, MAPL_undef, rc=STATUS)
         VERIFY_(STATUS)
      else
         Gout = Gin
      endif

      if(mCFIO%NBITS < 24) then
         call ESMF_CFIODownBit ( Gout, Gout, mCFIO%NBITS, undef=MAPL_undef, rc=STATUS )
         VERIFY_(STATUS)
      end if

      if(.not.AmRoot) then
         call MPI_Send(Gout, size(Gout), MPI_REAL, mCFIO%Root, &
              MPI_NULL_TAG, mCFIO%comm,                  STATUS)
         VERIFY_(STATUS)
      endif

      deallocate(Gin)
      nullify   (Gin)

      return
    end subroutine TransShaveAndSend

  end subroutine MAPL_CFIOWriteBundleWait

!===========================================================================

!BOP

! !IROUTINE: MAPL_CFIOWrite --- Writing Methods
! !IIROUTINE: MAPL_CFIOWriteBundle --- Writes an ESMF Bundle 

! !INTERFACE:
!
  subroutine MAPL_CFIOWriteBundle( MCFIO, CLOCK, Bundle, &
                                   VERBOSE, NBITS, RC    )
!
! !ARGUMENTS:
!
    type(MAPL_CFIO  ),                 intent(INOUT) :: MCFIO
    type(ESMF_CLOCK),       optional,  intent(IN   ) :: CLOCK
    type(ESMF_FIELDBUNDLE), optional,  intent(INout) :: BUNDLE
    logical,                optional,  intent(IN   ) :: VERBOSE
    integer,                optional,  intent(IN   ) :: NBITS
    integer,                optional,  intent(  OUT) :: RC
!
#ifdef ___PROTEX___

 !DESCRIPTION:  

       Writes an ESMF Bundle to a File. Only the MAPL\_CFIO object is
       a required argument as pointers to the actual data to be
       written is recorded in it during creation.

       {\tt CLOCK, BUNDLE} can be used to override the choice
       made at creation, but this is of dubious value, particularly
       for {\tt BUNDLE} since it must be excatly conformant with the
       creation {\tt BUNDLE}. {\tt NBITS} if the number of bits of 
       the mantissa to retain. This is used to write files with degraded
       precision, which can then be compressed with standard utilities.
       The default is no degradation of precision.

       {\bf A note about compression.} NetCDF-4, HDF-4 and HDF-5 all
       support transparent internal GZIP compression of the data being
       written. However, very little is gained by compressing float
       point fields from earth system models. Compression yields can
       be greatly increased by setting to zero bits in the mantissa of float
       numbers. On average 50\% compression can be achieved, while
       preserving a meaningful accuracy in the fields. Unlike
       classical CF compression by means of {\tt scale\_factor} and
       {\tt add\_offset} attributes, internal GZIP compression
       requires no special handling by the users of the data. In fact,
       they do not even need to know that the data is compressed! At this
       point, MAPL\_CFIO does not activate this GZIP compression
       feature in the files being written, but the resulting precision 
       degredaded files can be compressed offline with the HDF-4 
       {\tt hrepack} utility.

#endif

!EOP

    character(len=*), parameter:: Iam="MAPL_CFIOWriteBundle"
    integer                    :: status

    ASSERT_(present(CLOCK))
    ASSERT_(present(BUNDLE))

! for backward compatibility
!---------------------------

    if(present(NBITS)) then
       mCFIO%Nbits = Nbits
    end if

! DSK fName is set in History during runtime, but the G5 tutorial does not, so we must set it here
    if (IACHAR(MCFIO%fName(1:1)) == 0) then
       call MAPL_CFIOSet( MCFIO, fName=MCFIO%Name, RC=status )
       VERIFY_(STATUS)
    endif

    call MAPL_CFIOCreateWrite    ( MCFIO,         RC=status)
    VERIFY_(STATUS)

    call MAPL_CFIOWriteBundlePost( MCFIO,         RC=status)
    VERIFY_(STATUS)

    call MAPL_CFIOWriteBundleWait( MCFIO, CLOCK,  RC=status)
    VERIFY_(STATUS)

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_CFIOWriteBundle


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!BOP

! !IIROUTINE: MAPL_CFIOWriteState --- Writes an ESMF State

! !INTERFACE:
!
  subroutine MAPL_CFIOWriteState ( MCFIO, CLOCK, State, &
                                   VERBOSE, NBITS, RC   )
!
! !ARGUMENTS:
!
    type(MAPL_CFIO),             intent(INOUT) :: MCFIO
    type(ESMF_State),            intent(INout) :: STATE
    type(ESMF_CLOCK),            intent(IN   ) :: CLOCK
    integer, optional,           intent(  OUT) :: RC
    logical, optional,           intent(  IN)  :: VERBOSE
    integer, optional,           intent(  IN)  :: NBITS
!
#ifdef ___PROTEX___

    !DESCRIPTION:

     Serializes an ESMF state into a Bundle and writes it to a file.
     Only the MAPL\_CFIO object is a required argument as pointers to
     the actual data to be written is recorded in it during creation.

     {\tt CLOCK, BUNDLE} can be used to override the choice
     made at creation, but this is of dubious value, particularly
     for {\tt BUNDLE} since it must be excatly conformant with the
     creation {\tt BUNDLE}. {\tt NBITS} if the number of bits of 
     the mantissa to retain. This is used to write files with degraded
     precision, which can then be compressed with standard utilities.
     The default is no degradation of precision.

     {\bf A note about compression.} NetCDF-4, HDF-4 and HDF-5 all
     support transparent internal GZIP compression of the data being
     written. However, very little is gained by compressing float
     point fields from earth system models. Compression yields can
     be greatly increased by setting to zero bits in the mantissa of float
     numbers. On average 50\% compression can be achieved, while
     preserving a meaningful accuracy in the fields. Unlike
     classical CF compression by means of {\tt scale\_factor} and
     {\tt add\_offset} attributes, internal GZIP compression
     requires no special handling by the users of the data. In fact,
     they do not even need to know that the data is compressed! At this
     point, MAPL\_CFIO does not activate this GZIP compression
     feature in the files being written, but the resulting precision 
     degredaded files can be compressed offline with the HDF-4 
     {\tt hrepack} utility.

#endif

!EOP

    character(len=*), parameter  :: Iam="MAPL_CFIOWriteState"
    integer                      :: STATUS

! Locals

    type(ESMF_FieldBundle) :: tBUNDLE

! Get the appropriate bundle
!---------------------------

!!ALT    if(present(STATE)) then
       tBUNDLE = ESMF_FieldBundleCreate ( name=Iam, rc=STATUS )
       VERIFY_(STATUS)
       call ESMFL_BundleAddState_ ( tBUNDLE, STATE, rc=STATUS, VALIDATE=.true. )
       VERIFY_(STATUS)
!!ALT    else
!!ALT       tBUNDLE = MCFIO%BUNDLE
!!ALT    end if

!   Write the Bundle
!   ----------------

    call MAPL_CFIOWriteBundle ( MCFIO, CLOCK=CLOCK, BUNDLE=tBUNDLE, &
                                VERBOSE=VERBOSE, NBITS=NBITS, RC=STATUS   )
    VERIFY_(STATUS)

!!ALT    if(present(STATE)) then
       call ESMF_FieldBundleDestroy ( tBUNDLE, rc=STATUS )
       VERIFY_(STATUS)
!!ALT    endif

!   All done
!   --------

    RETURN_(ESMF_SUCCESS)

 end subroutine MAPL_CFIOWriteState

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!BOP

! !IROUTINE: MAPL_CFIORead --- Reading Methods
! !IIROUTINE: MAPL_CFIOReadBundle --- Reads an ESMF Bundle

! !INTERFACE:
!
  subroutine MAPL_CFIOReadBundle ( FILETMPL, TIME, BUNDLE, NOREAD, RC, &
                                   VERBOSE, FORCE_REGRID, ONLY_VARS,   &
                                   TIME_IS_CYCLIC, TIME_INTERP )
!
! !ARGUMENTS:
!
    character(len=*),            intent(IN   ) :: FILETMPL
    type(ESMF_TIME),             intent(INout) :: TIME
    type(ESMF_FIELDBUNDLE),           intent(INOUT) :: BUNDLE
    logical, optional,           intent(IN   ) :: NOREAD
    integer, optional,           intent(  OUT) :: RC
    logical, optional,           intent(IN)    :: VERBOSE
    logical, optional,           intent(IN)    :: FORCE_REGRID 
    logical, optional,           intent(IN)    :: TIME_IS_CYCLIC
    logical, optional,           intent(IN)    :: TIME_INTERP
    character(len=*), optional,  intent(IN)    :: ONLY_VARS 
!
#ifdef ___PROTEX___
    !DESCRIPTION: 

     Reads an ESMF Bundle from a file on a given time. The file is
     open, read from, and closed on exit. The arguments are:
\bd
     \item[FILETMPL] A GrADS-style file name template. In its simplest
     form is the full path name for the file to be read. However, it
     can contain the following tokens which will be expanded from
     the current time in {\em TIME}:
   \bd
        \item[\%y4] 4 digits for year
        \item[\%m2] 2 digits for month, to expand to 01, 02, .., 12
        \item[\%m3] 3 digits for month, to expand to jan, feb, mar, ..., dec
        \item[\%d2] 2 digits for day
        \item[\%h2] 2 digits for hour
        \item[\%n2] 2 digits for minutes
   \ed
    Example: if FILETMPL = ``forecast.\%y4-\%m2-\%d2\_%h2z.nc4'', and the clock
    says it is 18Z on 05 February 2007, the template will expand in the
    following file name: ``forecast.2007-02-05\_18Z.nc4''
%
    \item[TIME] The ESMF time to read from the file
%
    \item[BUNDLE] An ESMF Bundle to read the data in. When the Bundle is empty
    one field is added for each variable present in the input file, and the
    necessary memory allocated according to the ESMF grid present in the Bundle.
%
    \item[{[NOREAD]}] If .TRUE., no data is actually read into the Bundle. This is
    useful to define a Bundle with the same variables as presented in the
    file, which in turn can be used to created a MAPL\_CFIO object for
    writing.
%
    \item[{[RC]}] Error return code; set to ESMF\_SUCCESS if all is well.    
%
    \item[{[VERBOSE]}] If .TRUE., prints progress messages to STDOUT; useful
     for debugging.
%
    \item[{[FORCE\_REGRID]}] Obsolete; kept for backward compatibility but
    has no effect.
%
    \item[{[TIME\_IS\_CYCLIC]}]  If .TRUE. it says that the input file is periodic
    in time. Useful for reading climatological files. For example, if the
    input file has 12 monthly means from January to December of 2001, setting
    this option to .TRUE. allows one to read this data for any other year. See 
    note below regarding issues with reading monthly mean data.
%
    \item[{[TIME\_INTERP]}] If .TRUE., the input file does not have to coincide with the
    actual times on file. In such cases, the data for the bracketing times are
    read and the data is properly interpolated in time. The input time, though,
    need to be within the range of times present on file 
   (unless {\tt TIME\_IS\_CYCLIC} is specified).
%
    \item[{[ONLY\_VARS]}] A list of comma separated vafriables to be read from the
    file. By default, all variables are read from the file. This option allows
    one to read a subset of vafriables. Example: ONLY\_VARS=``u,v,ps''.
%
\ed

    {\bf A note about storing monthly climatological data.} As per the CF
    conventions, month is not a well defined unit of time, as the time
    step is not constant throughout the year. When storing 12 months
    of climatological data one way around it is to use an average
    number of hours: use 732 or 730 hours depending on whether the year
    recorded in the file is a leap-year or not.

     !DESIGN ISSUES:

     The input argument {\tt TIME} should be replaced with {\tt CLOCK}
     for consistency with the rest of the API. One should also provide
     an interface involving the MAPL CFIO object.

#endif

!EOP
!--------------------------------------------------------------------------------
    character(len=*), parameter  :: Iam="MAPL_CFIOReadBundle"
    integer                      :: STATUS

! Locals


    type(ESMF_CFIO)              :: CFIO
    type(ESMF_CFIOGrid), pointer :: CFIOGRID
    type(ESMF_GRID)              :: ESMFGRID
    type(ESMF_FIELD)             :: FIELD
    type(ESMF_ARRAY)             :: ARRAY
    type(ESMF_VM)                :: VM

    type(ESMF_CFIOVarInfo), pointer :: VARS(:)

    type(MAPL_HORZTRANSFORM)          :: Trans
    integer                      :: IM,  JM,  LM
    integer                      :: IM0, JM0
    integer                      :: L1, L, K
    integer                      :: NumVars, nVars
    integer                      :: counts(5)
    integer                      :: dims(3)
    integer                      :: arrayRank

    logical                      :: IamRoot, twoD

    real, pointer                ::  PTR2      (:,:),  PTR3      (:,:,:)
    real, pointer                :: GPTR2bundle(:,:), GPTR3bundle(:,:,:)
    real, pointer                :: GPTR2file  (:,:), GPTR3file  (:,:,:)

    character(len=ESMF_MAXSTR)   :: NAME
    character(len=ESMF_MAXSTR)   :: DATE
    character(len=ESMF_MAXSTR)   :: BundleVARNAME
    character(len=ESMF_MAXSTR)   :: CFIOVARNAME

    real, pointer :: LONSfile(:),   LATSfile(:)
    real, pointer :: LONSbundle(:), LATSbundle(:) => NULL()

    character(len=ESMF_MAXSTR) :: FILENAME
    integer :: nymd, nhms
    logical :: timeInterp=.false., VERB = .false., change_resolution, do_xshift
    integer, allocatable    :: gridToFieldMap(:)
    integer                 :: gridRank

!                              ---
    
    if ( present(VERBOSE) )     VERB = VERBOSE
    if ( present(TIME_INTERP) ) timeInterp = TIME_INTERP

! Create a CFIO object named after the bundle
!--------------------------------------------
    call ESMF_FieldBundleGet     (Bundle,   name=NAME,                         RC=STATUS)
    VERIFY_(STATUS)
    cfio =  ESMF_CFIOCreate (          cfioObjName=trim(Name),            RC=STATUS)
    VERIFY_(STATUS)

! Transform ESMF time to string for use in CFIO
!----------------------------------------------
    call ESMF_TimeGet       (TIME,     timeString=DATE,                   RC=STATUS)
    VERIFY_(STATUS)

    call strToInt(DATE, nymd, nhms)
    call ESMF_CFIOstrTemplate ( filename, filetmpl, 'GRADS', &
                                nymd=nymd, nhms=nhms, stat=status )
    VERIFY_(STATUS)
    call WRITE_PARALLEL("CFIO: Reading " // trim(filename))
                                                                                              
! Set its filename and open it for reading
!-----------------------------------------
    call ESMF_CFIOSet       (CFIO, fName=trim(fileName), RC=STATUS)
    VERIFY_(STATUS)

    call ESMF_CFIOFileOpen  (CFIO, FMODE=1, cyclic=TIME_IS_CYCLIC, RC=STATUS)
    VERIFY_(STATUS)

! Get info from the bundle
!-------------------------
    call ESMF_VMGetCurrent(VM, RC=STATUS)
    VERIFY_(STATUS)

    call ESMF_FieldBundleGet     (Bundle, FieldCount=NUMVARS, RC=STATUS)
    VERIFY_(STATUS)

    IamRoot = MAPL_AM_I_ROOT(VM)

! Get info from the CFIO object
!------------------------------
    call ESMF_CFIOGet       (CFIO,     grid=CFIOGRID,                     RC=STATUS)
    VERIFY_(STATUS)
    call ESMF_CFIOGridGet   (CFIOGRID, IM=IM, JM=JM, KM=LM,               RC=STATUS)
    VERIFY_(STATUS)

    allocate(LONSfile(IM), LATSfile(JM), stat=status )
    VERIFY_(STATUS)
    call ESMF_CFIOGridGet    (CFIOGRID, LON=LONSFILE, LAT=LATSFILE, RC=STATUS)
    VERIFY_(STATUS)

    call ESMF_CFIOGet (CFIO,varObjs=VARS, nVars=nVars, RC=STATUS)
    VERIFY_(STATUS)


! If the bundle is empty, read entire varlist from file
!------------------------------------------------------

    if(NUMVARS==0) then

       call ESMF_FieldBundleGet     (Bundle,   Grid=ESMFGRID, RC=STATUS)
       VERIFY_(STATUS)
       call MAPL_GridGet(ESMFGRID, globalCellCountPerDim=COUNTS, &
            localCellCountPerDim=DIMS, RC=STATUS)
       VERIFY_(STATUS)
       ! Assert compatibility of file and bundle
       !----------------------------------------
       ASSERT_( LM==0 .or. counts(3) == 0 .or. LM==counts(3) )

       ! Get lat/lons of input bundle
       ! ----------------------------
       call GridGetLatLons_ ( ESMFGRID, LONSbundle, LATSbundle, rc=status )
       VERIFY_(STATUS)

       NUMVARS = nVars

       L1 = 0
       do L=1,NUMVARS

          call ESMF_CFIOVarInfoGet(VARS(L),vname=CFIOVARNAME, twoDimVar=twoD, RC=STATUS)   
          VERIFY_(STATUS)

          if ( present(ONLY_VARS) ) then
               if ( index(','//trim(ONLY_VARS)  //',', &
                          ','//trim(CFIOVARNAME)//',') < 1 ) cycle 
          endif

          L1 = L1 + 1

          BundleVarName = CFIOVARNAME
          if(twoD) then
            allocate(PTR2(DIMS(1),DIMS(2)),stat=STATUS)
            VERIFY_(STATUS)
            PTR2  = 0.0

            call ESMF_GridGet(ESMFGRID, dimCount=gridRank, rc=status)
            VERIFY_(STATUS)
            allocate(gridToFieldMap(gridRank), stat=status)
            VERIFY_(STATUS)
            if(gridRank == 2) then
               gridToFieldMap(1) = 1
               gridToFieldMap(2) = 2
            else if (gridRank == 3) then
               gridToFieldMap(1) = 1
               gridToFieldMap(2) = 2
               gridToFieldMap(3) = 0
            else
               RETURN_(ESMF_FAILURE)
            end if

            FIELD = ESMF_FieldCreate(grid=ESMFGRID, copyflag=ESMF_DATA_REF,   &
                            farrayPtr=PTR2, gridToFieldMap=gridToFieldMap, &
                            name=BundleVARNAME, RC=STATUS)
            VERIFY_(STATUS)

            deallocate(gridToFieldMap)

!ALT: for now we add only HorzOnly (no tiles)
            call ESMF_AttributeSet(FIELD, NAME='DIMS', VALUE=MAPL_DimsHorzOnly, RC=STATUS)
            VERIFY_(STATUS)
            call ESMF_AttributeSet(FIELD, NAME='VLOCATION', &
                                        VALUE=MAPL_VLocationNone, RC=STATUS)
            VERIFY_(STATUS) 
          else 
            allocate(PTR3(DIMS(1),DIMS(2),LM),stat=STATUS)
            VERIFY_(STATUS)
            PTR3  = 0.0
            FIELD = ESMF_FieldCreate(grid=ESMFGRID, copyflag=ESMF_DATA_REF,   &
                            farrayPtr=PTR3, name=BundleVARNAME, RC=STATUS)
            VERIFY_(STATUS)
!ALT: for now we add only HorzVert (no tiles)
            call ESMF_AttributeSet(FIELD, NAME='DIMS', VALUE=MAPL_DimsHorzVert, RC=STATUS)
            VERIFY_(STATUS)
            call ESMF_AttributeSet(FIELD, NAME='VLOCATION', &
                                        VALUE=MAPL_VLocationCenter, RC=STATUS)
            VERIFY_(STATUS)
          end if
          call ESMF_FieldBundleAdd(BUNDLE,FIELD,                          RC=STATUS)
          VERIFY_(STATUS)

       end do
       NUMVARS = L1  ! could be less than on file if user chooses to

    else
       
       do L=1,NumVars
          call ESMF_FieldBundleGet (BUNDLE, L, FIELD,                     RC=STATUS)
          VERIFY_(STATUS)
          call ESMF_FieldGet(FIELD,NAME=BundleVarName,array=ARRAY, RC=STATUS)
          VERIFY_(STATUS)
          call ESMF_FieldGet(FIELD,   Grid=ESMFGRID, RC=STATUS)
          VERIFY_(STATUS)
          call MAPL_GridGet(ESMFGRID, globalCellCountPerDim=COUNTS, RC=STATUS)
          VERIFY_(STATUS)
          ! Assert compatibility of file and bundle
          !----------------------------------------
          ASSERT_( LM==0 .or. counts(3) == 0 .or. LM==counts(3) )

          ! Get lat/lons of input bundle
          ! ----------------------------
          call GridGetLatLons_ ( ESMFGRID, LONSbundle, LATSbundle, rc=status )
          VERIFY_(STATUS)

          do K=1,size(VARS)
             call ESMF_CFIOVarInfoGet(VARS(K),vname=CFIOVARNAME,          RC=STATUS)
             VERIFY_(STATUS)
             if(trim(BUNDLEVARNAME)==trim(CFIOVARNAME)) exit
          end do
!ams      ASSERT_(K<=size(VARS)) ! K is generally not defined at this point!
       end do

    end if

    if(present(NOREAD)) then
       if(NOREAD) then
          RETURN_(ESMF_SUCCESS)
       end if
    end if


! Allocate space for global arrays. Only root will use these
!-----------------------------------------------------------

    IM0 = counts(1)
    JM0 = counts(2)

    allocate(Gptr2bundle(IM0,JM0   ), stat=STATUS)
    VERIFY_(STATUS)
    allocate(Gptr3bundle(IM0,JM0,LM), stat=STATUS)
    VERIFY_(STATUS)
    allocate(Gptr2file  (IM ,JM    ), stat=STATUS)
    VERIFY_(STATUS)
    allocate(Gptr3file  (IM ,JM ,LM), stat=STATUS)
    VERIFY_(STATUS)

    if (IM /= IM0 .or. JM /= JM0)  then
        change_resolution = .true.
    else                              
        change_resolution = .false.
    end if

!    if ( present(FORCE_REGRID) ) then
!         change_resolution = change_resolution .OR. FORCE_REGRID
!    endif

    if (MAPL_AM_I_ROOT(VM)) then
       if ( change_resolution ) then
!          if (IM0 <  IM .or. JM0 < JM) then
             call MAPL_HorzTransformCreate (Trans, im, jm, im0, jm0, rc=STATUS)
             VERIFY_(STATUS)
!          end if
       end if
    end if

    do_xshift =  abs(LONSbundle(1)-LONSfile(1)+180.) .LE. &
                (abs(LONSbundle(2)-LONSbundle(1)) * 1000. * epsilon(1.0))

! Read each variable
!-------------------
    do L=1,NumVars

       call ESMF_FieldBundleGet (BUNDLE, L, FIELD,                       RC=STATUS)
       VERIFY_(STATUS)
       call ESMF_FieldGet       (FIELD, NAME=BundleVarName, array=ARRAY, RC=STATUS)
       VERIFY_(STATUS)
       call ESMF_FieldGet(FIELD,   Grid=ESMFGRID, RC=STATUS)
       VERIFY_(STATUS)
       call ESMF_ArrayGet       (array, rank=arrayRank,                  RC=STATUS)
 
       VERIFY_(STATUS)

       if ( VERB .and. IamRoot ) &
            print *, Iam // ': Reading '//trim(BundleVARNAME)// &
                            ' at ' // trim(date)
       select case (arrayRank)

       case (2)

          call ESMF_ArrayGet(Array, localDE=0, farrayptr=PTR2, RC=STATUS)
          VERIFY_(STATUS)

          if (IamRoot) then
             if ( timeInterp ) then
                call ESMF_CFIOVarReadT(CFIO, trim(BundleVARNAME), GPTR2file, &
                                       timeString=DATE, RC=STATUS)
             else
                call ESMF_CFIOVarRead (CFIO, trim(BundleVARNAME), GPTR2file, &
                                       timeString=DATE, RC=STATUS)
             endif
             VERIFY_(STATUS)
             if (change_resolution) then  
!                if (IM0 <  IM .OR. JM0 < JM) then
                   if ( VERB ) print *, Iam // ': Binning... '
                   call MAPL_HorzTransformRun(Trans, Gptr2file, Gptr2bundle, MAPL_undef, rc=STATUS )
                   VERIFY_(STATUS)
 !               else
 !                  if ( VERB ) print *, Iam // ': Interpolating... '
 !                  call hinterp ( Gptr2file,im,jm, Gptr2bundle,im0,jm0,1,MAPL_Undef )
 !               end if ! coarsening
             else
                Gptr2bundle = Gptr2file
             end if ! change resolution
             if ( do_xshift ) then
                 if ( VERB ) print *, Iam // &
                      ': shifting input longitudes by 180 degrees'
                 call shift180Lon2D_ ( Gptr2bundle, im0, jm0 )
             end if
          end if

          call ArrayScatter(PTR2, GPTR2bundle, ESMFGRID, RC=STATUS)
          VERIFY_(STATUS)

       case(3)

          call ESMF_ArrayGet(array, localDE=0, farrayptr=PTR3, RC=STATUS)
          VERIFY_(STATUS)

!         TO DO: Read one level at a time and scatter
!         -------------------------------------------
          if (IamRoot) then
             if ( timeInterp ) then
                call ESMF_CFIOVarReadT(CFIO, trim(BundleVARNAME), GPTR3file, &
                                             timeString=DATE, RC=STATUS)
             else
                call ESMF_CFIOVarRead (CFIO, trim(BundleVARNAME), GPTR3file, &
                                             timeString=DATE, RC=STATUS)
             end if
             VERIFY_(STATUS)
             if (change_resolution) then
!                if (IM0 <  IM .or. JM0 < JM) then
                    if ( VERB ) print *, Iam // ': Binning... '
                    do k = 1, LM
                       call MAPL_HorzTransformRun(Trans, Gptr3file(:,:,k), &
                                                Gptr3bundle(:,:,k), MAPL_undef, rc=STATUS)
                       VERIFY_(STATUS)
                    end do
!                else
!                   if ( VERB ) print *, Iam // ': Interpolating... '
!                   call hinterp ( Gptr3file,im,jm, Gptr3bundle,im0,jm0,LM,MAPL_Undef )
!                end if ! coarsening
             else
                Gptr3bundle = Gptr3file
             end if
             if ( do_xshift ) then
                 if ( VERB ) print *, Iam // &
                      ': shifting input longitudes by 180 degrees'
                  do k = 1, LM
                     call shift180Lon2D_ ( Gptr3bundle(:,:,K), im0, jm0 )
                  end do 
             end if

          end if ! I am root

          L1 = LBOUND(PTR3,3)-1

          do K=1,LM
             call ArrayScatter(PTR3(:,:,K+L1), Gptr3bundle(:,:,K), ESMFGRID, RC=STATUS)
             VERIFY_(STATUS)
          end do

       case default

       end select

    end do

    if (MAPL_AM_I_ROOT(VM)) then
       if ( change_resolution ) then
!          if (IM <  IM0 .or. JM < JM0) then
             call MAPL_HorzTransformDestroy(Trans,rc=STATUS)
             VERIFY_(STATUS)
!          end if
       end if
    end if

    deallocate(GPtr2bundle)
    deallocate(GPtr3bundle)
    deallocate(GPtr2file  )
    deallocate(GPtr3file  )
    deallocate(LONSfile,LATSfile)
    deallocate(LONSbundle,LATSbundle)

    RETURN_(ESMF_SUCCESS)

CONTAINS

    subroutine shift180Lon2D_ ( c, im, jm )
    integer, intent(in) :: im, jm
    real, intent(inout) :: c(im,jm)
    real :: cj(im)
    integer :: m(4), n(4), imh, j
    imh = nint(im/2.)
    m = (/ 1,      imh, 1+imh,    im   /)
    n = (/ 1,   im-imh, 1+im-imh, im   /)
    do j = 1, jm
       cj(n(1):n(2)) = c(m(3):m(4),j)
       cj(n(3):n(4)) = c(m(1):m(2),j)
       c(:,j) = cj
    end do
    return
    end subroutine shift180Lon2D_

  end subroutine MAPL_CFIOReadBundle

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!BOP

! !IIROUTINE: MAPL_CFIOReadState --- Reads an ESMF State

! !INTERFACE:
!
  subroutine MAPL_CFIOReadState ( FILETMPL, TIME, STATE, NOREAD, RC, &
                                  VERBOSE, FORCE_REGRID, ONLY_VARS,   &
                                  TIME_IS_CYCLIC, TIME_INTERP )
!
! !ARGUMENTS:
!
    character(len=*),            intent(IN   ) :: FILETMPL
    type(ESMF_TIME),             intent(INout) :: TIME
    type(ESMF_STATE),            intent(INOUT) :: STATE
    logical, optional,           intent(IN   ) :: NOREAD
    integer, optional,           intent(  OUT) :: RC
    logical, optional,           intent(  IN)  :: VERBOSE
    logical, optional,           intent(IN)    :: FORCE_REGRID ! obsolete
    logical, optional,           intent(IN)    :: TIME_IS_CYCLIC
    logical, optional,           intent(IN)    :: TIME_INTERP
    character(len=*), optional,  intent(IN   ) :: ONLY_VARS ! comma separated,
                                                            ! no spaces
!
#ifdef ___PROTEX___
!
    !DESCRIPTION: 

     Serializes an ESMF state into a Bundle and reads its content from
     a file. The file is open, read from, and closed on exit. The
     arguments are:
\bd
     \item[FILETMPL] A GrADS-style file name template. In its simplest
     form is the full path name for the file to be read. However, it
     can contain the following tokens which will be expanded from
     the current time in {\em TIME}:
   \bd
        \item[\%y4] 4 digits for year
        \item[\%m2] 2 digits for month, to expand to 01, 02, .., 12
        \item[\%m3] 3 digits for month, to expand to jan, feb, mar, ..., dec
        \item[\%d2] 2 digits for day
        \item[\%h2] 2 digits for hour
        \item[\%n2] 2 digits for minutes
   \ed
    Example: if FILETMPL = ``forecast.\%y4-\%m2-\%d2\_%h2z.nc4'', and the clock
    says it is 18Z on 05 February 2007, the template will expand in the
    following file name: ``forecast.2007-02-05\_18Z.nc4''
%
    \item[TIME] The ESMF time to read from the file
%
    \item[STATE] An ESMF State to read the data in. Usually used in conjubction
    with ONLY\_VARS.
%
    \item[{[NOREAD]}] If .TRUE., no data is actually read into the Bundle. This is
    useful to define a Bundle with the same variables as presented in the
    file, which in turn can be used to created a MAPL\_CFIO object for
    writing.
%
    \item[{[RC]}] Error return code; set to ESMF\_SUCCESS if all is well.    
%
    \item[{[VERBOSE]}] If .TRUE., prints progress messages to STDOUT; useful
     for debugging.
%
    \item[{[FORCE\_REGRID]}] Obsolete; kept for backward compatibility but
    has no effect.
%
    \item[{[TIME\_IS\_CYCLIC]}]  If .TRUE. it says that the input file is periodic
    in time. Useful for reading climatological files. For example, if the
    input file has 12 monthly means from January to December of 2001, setting
    this option to .TRUE. allows one to read this data for any other year. See 
    note below regarding issues with reading monthly mean data.
%
    \item[{[TIME\_INTERP]}] If .TRUE., the input file does not have to coincide with the
    actual times on file. In such cases, the data for the bracketing times are
    read and the data is properly interpolated in time. The input time, though,
    need to be within the range of times present on file 
   (unless {\tt TIME\_IS\_CYCLIC} is specified).
%
    \item[{[ONLY\_VARS]}] A list of comma separated vafriables to be read from the
    file. By default, all variables are read from the file. This option allows
    one to read a subset of vafriables. Example: ONLY\_VARS=``u,v,ps''.
%
\ed

     !DESIGN ISSUES:

     The input argument {\tt TIME} should be replaced with {\tt CLOCK}
     for consistency with the rest of the API. One should also provide
     an interface involving the MAPL CFIO object.

#endif

!EOP

    character(len=*), parameter  :: Iam="MAPL_CFIOReadState"
    integer                      :: STATUS

! Locals

    type(ESMF_FieldBundle) :: tBUNDLE

!                          ----

!   Create an empty bundle
!   ----------------------
    tBUNDLE = ESMF_FieldBundleCreate ( name=Iam, rc=STATUS )
    VERIFY_(STATUS)
    
!   Serialize the state
!   -------------------
    call ESMFL_BundleAddState_ ( tBUNDLE, STATE, rc=STATUS, VALIDATE=.true. )
    VERIFY_(STATUS)

!   Read the Bundle
!   ---------------
    call MAPL_CFIOReadBundle( FILETMPL, TIME, tBUNDLE,         &
                              NOREAD = NOREAD,                 &
                              VERBOSE = VERBOSE,               &
                              FORCE_REGRID=FORCE_REGRID,       &
                              ONLY_VARS = ONLY_VARS,           &
                              TIME_IS_CYCLIC = TIME_IS_CYCLIC, &
                              TIME_INTERP = TIME_INTERP,       &
                              RC = STATUS )

    VERIFY_(STATUS)

!   All done
!   --------
    call ESMF_FieldBundleDestroy ( tBUNDLE, rc=STATUS )
    VERIFY_(STATUS)

    RETURN_(ESMF_SUCCESS)

 end subroutine MAPL_CFIOReadState

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!BOP

! !IIROUTINE: MAPL_CFIOReadField --- Reads an ESMF Field

! !INTERFACE:
!
  subroutine MAPL_CFIOReadField     ( VARN, FILETMPL, TIME,       FIELD, RC, &
                                      VERBOSE, FORCE_REGRID, TIME_IS_CYCLIC, &
                                      TIME_INTERP )
!
! !ARGUMENTS:
!
    character(len=*),            intent(IN   ) :: VARN       ! Variable name
    character(len=*),            intent(IN   ) :: FILETMPL   ! File name
    type(ESMF_TIME),             intent(INout) :: TIME
    type(ESMF_FIELD),            intent(INout) :: FIELD
    integer, optional,           intent(  OUT) :: RC
    logical, optional,           intent(  IN)  :: VERBOSE
    logical, optional,           intent(IN)    :: FORCE_REGRID
    logical, optional,           intent(IN)    :: TIME_IS_CYCLIC
    logical, optional,           intent(IN)    :: TIME_INTERP
!
#ifdef ___PROTEX___

    !DESCRIPTION: 

     Reads a variable from a file and stores it on an ESMF Field.
     The file is open, read from, and closed on exit. The
     arguments are:
\bd
     \item[VARN] The variable name.
%
     \item[FILETMPL] A GrADS-style file name template. In its simplest
     form is the full path name for the file to be read. However, it
     can contain the following tokens which will be expanded from
     the current time in {\em TIME}:
   \bd
        \item[\%y4] 4 digits for year
        \item[\%m2] 2 digits for month, to expand to 01, 02, .., 12
        \item[\%m3] 3 digits for month, to expand to jan, feb, mar, ..., dec
        \item[\%d2] 2 digits for day
        \item[\%h2] 2 digits for hour
        \item[\%n2] 2 digits for minutes
   \ed
    Example: if FILETMPL = ``forecast.\%y4-\%m2-\%d2\_%h2z.nc4'', and the clock
    says it is 18Z on 05 February 2007, the template will expand in the
    following file name: ``forecast.2007-02-05\_18Z.nc4''
%
    \item[TIME] The ESMF time to read from the file
%
    \item[{[RC]}] Error return code; set to ESMF\_SUCCESS if all is well.    
%
    \item[{[VERBOSE]}] If .TRUE., prints progress messages to STDOUT; useful
     for debugging.
%
    \item[{[FORCE\_REGRID]}] Obsolete; kept for backward compatibility but
    has no effect.
%
    \item[{[TIME\_IS\_CYCLIC]}]  If .TRUE. it says that the input file is periodic
    in time. Useful for reading climatological files. For example, if the
    input file has 12 monthly means from January to December of 2001, setting
    this option to .TRUE. allows one to read this data for any other year. See 
    note below regarding issues with reading monthly mean data.
%
    \item[{[TIME\_INTERP]}] If .TRUE., the input file does not have to coincide with the
    actual times on file. In such cases, the data for the bracketing times are
    read and the data is properly interpolated in time. The input time, though,
    need to be within the range of times present on file 
   (unless {\tt TIME\_IS\_CYCLIC} is specified).
%
    \item[{[ONLY\_VARS]}] A list of comma separated vafriables to be read from the
    file. By default, all variables are read from the file. This option allows
    one to read a subset of vafriables. Example: ONLY\_VARS=``u,v,ps''.
%
\ed

     !DESIGN ISSUES:

     The input argument {\tt TIME} should be replaced with {\tt CLOCK}
     for consistency with the rest of the API. The input {\tt GRID} is not necessary
     as it can be found inside the field. One should also provide
     an interface involving the MAPL CFIO object.

#endif

!EOP

    character(len=*), parameter  :: Iam="MAPL_CFIOReadField"
    integer                      :: STATUS
    type(ESMF_GRID)              :: GRID

! Locals

    type(ESMF_FIELDBUNDLE)  :: BUNDLE
 
!   Create a temporary empty bundle
!   -------------------------------
    call ESMF_FieldGet(Field,Grid, rc=status)
    VERIFY_(STATUS)
    BUNDLE =  ESMF_FieldBundleCreate ( grid=GRID, name=Iam, rc=STATUS )
    VERIFY_(STATUS)

!   Add the input field to the bundle
!   ---------------------------------
    call ESMF_FieldBundleAdd ( BUNDLE, FIELD, rc=STATUS )
    VERIFY_(STATUS)

!   Now, we read the variable into the bundle, which in turn will put
!    the data inside the input array
!   -----------------------------------------------------------------
    call MAPL_CFIOReadBundle( FILETMPL, TIME, BUNDLE,                    &
                              VERBOSE=VERBOSE,                           &
                              FORCE_REGRID=FORCE_REGRID,                 &
                              ONLY_VARS = trim(varn),                    &
                              TIME_IS_CYCLIC=TIME_IS_CYCLIC,             &
                              TIME_INTERP=TIME_INTERP, RC=STATUS         )
    VERIFY_(STATUS)    


!   Destroy temporary bundle; field data will be preserved
!   ------------------------------------------------------
    call ESMF_FieldBundleDestroy ( BUNDLE, rc=STATUS )
    VERIFY_(STATUS)    

    RETURN_(ESMF_SUCCESS)

  end subroutine MAPL_CFIOReadField

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!BOP

! !IIROUTINE: MAPL_CFIOReadArray3D --- Reads a 3D Fortran Array

! !INTERFACE:
!
  subroutine MAPL_CFIOReadArray3D ( VARN, FILETMPL, TIME, GRID, fARRAY, RC, &
                                    VERBOSE, FORCE_REGRID, TIME_IS_CYCLIC,  &
                                    TIME_INTERP )
!
! !ARGUMENTS:
!
    character(len=*),            intent(IN   ) :: VARN       ! Variable name
    character(len=*),            intent(IN   ) :: FILETMPL   ! File name
    type(ESMF_TIME),             intent(INout) :: TIME
    type(ESMF_GRID),             intent(IN   ) :: GRID
    real, pointer                              :: fARRAY(:,:,:)
    integer, optional,           intent(  OUT) :: RC
    logical, optional,           intent(  IN)  :: VERBOSE
    logical, optional,           intent(IN)    :: FORCE_REGRID
    logical, optional,           intent(IN)    :: TIME_IS_CYCLIC
    logical, optional,           intent(IN)    :: TIME_INTERP
!
#ifdef ___PROTEX___

    !DESCRIPTION: 

     Reads a variable from a file and stores it on an 3D Fortrran array.
     The file is open, read from, and closed on exit. The
     arguments are:
\bd
     \item[VARN] The variable name.
%
     \item[FILETMPL] A GrADS-style file name template. In its simplest
     form is the full path name for the file to be read. However, it
     can contain the following tokens which will be expanded from
     the current time in {\em TIME}:
   \bd
        \item[\%y4] 4 digits for year
        \item[\%m2] 2 digits for month, to expand to 01, 02, .., 12
        \item[\%m3] 3 digits for month, to expand to jan, feb, mar, ..., dec
        \item[\%d2] 2 digits for day
        \item[\%h2] 2 digits for hour
        \item[\%n2] 2 digits for minutes
   \ed
    Example: if FILETMPL = ``forecast.\%y4-\%m2-\%d2\_%h2z.nc4'', and the clock
    says it is 18Z on 05 February 2007, the template will expand in the
    following file name: ``forecast.2007-02-05\_18Z.nc4''
%
    \item[TIME] The ESMF time to read from the file
%
    \item[GRID] The ESMF grid associated with the Field. The data will be 
    (horizontally) interpolated to this grid if necessary.
%
    \item[{[RC]}] Error return code; set to ESMF\_SUCCESS if all is well.    
%
    \item[{[VERBOSE]}] If .TRUE., prints progress messages to STDOUT; useful
     for debugging.
%
    \item[{[FORCE\_REGRID]}] Obsolete; kept for backward compatibility but
    has no effect.
%
    \item[{[TIME\_IS\_CYCLIC]}]  If .TRUE. it says that the input file is periodic
    in time. Useful for reading climatological files. For example, if the
    input file has 12 monthly means from January to December of 2001, setting
    this option to .TRUE. allows one to read this data for any other year. See 
    note below regarding issues with reading monthly mean data.
%
    \item[{[TIME\_INTERP]}] If .TRUE., the input file does not have to coincide with the
    actual times on file. In such cases, the data for the bracketing times are
    read and the data is properly interpolated in time. The input time, though,
    need to be within the range of times present on file 
   (unless {\tt TIME\_IS\_CYCLIC} is specified).
%
    \item[{[ONLY\_VARS]}] A list of comma separated vafriables to be read from the
    file. By default, all variables are read from the file. This option allows
    one to read a subset of vafriables. Example: ONLY\_VARS=``u,v,ps''.
%
\ed

     !DESIGN ISSUES:

     The input argument {\tt TIME} should be replaced with {\tt CLOCK}
     for consistency with the rest of the API.  One should also
     provide an interface involving the MAPL CFIO object.

#endif

!EOP

    character(len=*), parameter  :: Iam="MAPL_CFIOReadArray3D"
    integer                      :: STATUS

    type(ESMF_Field)             :: FIELD

    real    :: const = 0.0
    integer :: ios, k

!                            ----

!   Special case: when filename is "/dev/null" it is assumed the user 
!   wants to set the variable to a constant
!   -----------------------------------------------------------------
    if ( FILETMPL(1:9) == '/dev/null' ) then    
         ios = -1
         k = index(FILETMPL,':')
         if ( k > 9 ) read(FILETMPL(k+1:),*,iostat=ios) const
         if ( ios /= 0 ) const = 0.0
         if ( MAPL_am_I_root() ) &
            print *, Iam // ': setting variable ' // trim(varn) // &
                            ' to constant = ', const
         RETURN_(ESMF_SUCCESS)
    end if

!   Create Field with input array
!   -----------------------------
    FIELD = ESMF_FieldCreate(grid=GRID, copyflag=ESMF_DATA_REF,   &
            farrayPtr=fARRAY, name=trim(varn), RC=STATUS)
    VERIFY_(STATUS)

   
!   Read array data from file
!   -------------------------
    call MAPL_CFIOReadField ( VARN, FILETMPL, TIME,       FIELD,          &
                              VERBOSE=VERBOSE, FORCE_REGRID=FORCE_REGRID, &
                              TIME_IS_CYCLIC=TIME_IS_CYCLIC,              &
                              TIME_INTERP=TIME_INTERP, RC=STATUS         )
    VERIFY_(STATUS)

!   Destroy the ESMF array (data will be preserved since we own it)
!   --------------------------------------------------------------
    call ESMF_FieldDestroy ( FIELD, STATUS )
    VERIFY_(STATUS)

    RETURN_(ESMF_SUCCESS)

  end subroutine MAPL_CFIOReadArray3D

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!BOP

! !IIROUTINE: MAPL_CFIOReadArray2D --- Reads a 2D Fortran Array

! !INTERFACE:
!
  subroutine MAPL_CFIOReadArray2D ( VARN, FILETMPL, TIME, GRID, fARRAY, RC, &
                                    VERBOSE, FORCE_REGRID, TIME_IS_CYCLIC,  &
                                    TIME_INTERP )
!
! !ARGUMENTS:
!
    character(len=*),            intent(IN)  :: VARN       ! Variable name
    character(len=*),            intent(IN)  :: FILETMPL   ! File name
    type(ESMF_TIME),             intent(INout)  :: TIME
    type(ESMF_GRID),             intent(IN)  :: GRID
    real, pointer                            :: fARRAY(:,:)
    integer, optional,           intent(OUT) :: RC
    logical, optional,           intent(IN)  :: VERBOSE
    logical, optional,           intent(IN)  :: FORCE_REGRID
    logical, optional,           intent(IN)  :: TIME_IS_CYCLIC
    logical, optional,           intent(IN)  :: TIME_INTERP
!
#ifdef ___PROTEX___

    !DESCRIPTION: 

     Reads a variable from a file and stores it on an 3D Fortrran array.
     The file is open, read from, and closed on exit. The
     arguments are:
\bd
     \item[VARN] The variable name.
%
     \item[FILETMPL] A GrADS-style file name template. In its simplest
     form is the full path name for the file to be read. However, it
     can contain the following tokens which will be expanded from
     the current time in {\em TIME}:
   \bd
        \item[\%y4] 4 digits for year
        \item[\%m2] 2 digits for month, to expand to 01, 02, .., 12
        \item[\%m3] 3 digits for month, to expand to jan, feb, mar, ..., dec
        \item[\%d2] 2 digits for day
        \item[\%h2] 2 digits for hour
        \item[\%n2] 2 digits for minutes
   \ed
    Example: if FILETMPL = ``forecast.\%y4-\%m2-\%d2\_%h2z.nc4'', and the clock
    says it is 18Z on 05 February 2007, the template will expand in the
    following file name: ``forecast.2007-02-05\_18Z.nc4''
%
    \item[TIME] The ESMF time to read from the file
%
    \item[GRID] The ESMF grid associated with the Field. The data will be 
    (horizontally) interpolated to this grid if necessary.
%
    \item[{[RC]}] Error return code; set to ESMF\_SUCCESS if all is well.    
%
    \item[{[VERBOSE]}] If .TRUE., prints progress messages to STDOUT; useful
     for debugging.
%
    \item[{[FORCE\_REGRID]}] Obsolete; kept for backward compatibility but
    has no effect.
%
    \item[{[TIME\_IS\_CYCLIC]}]  If .TRUE. it says that the input file is periodic
    in time. Useful for reading climatological files. For example, if the
    input file has 12 monthly means from January to December of 2001, setting
    this option to .TRUE. allows one to read this data for any other year. See 
    note below regarding issues with reading monthly mean data.
%
    \item[{[TIME\_INTERP]}] If .TRUE., the input file does not have to coincide with the
    actual times on file. In such cases, the data for the bracketing times are
    read and the data is properly interpolated in time. The input time, though,
    need to be within the range of times present on file 
   (unless {\tt TIME\_IS\_CYCLIC} is specified).
%
    \item[{[ONLY\_VARS]}] A list of comma separated vafriables to be read from the
    file. By default, all variables are read from the file. This option allows
    one to read a subset of vafriables. Example: ONLY\_VARS=``u,v,ps''.
%
\ed

     !DESIGN ISSUES:

     The input argument {\tt TIME} should be replaced with {\tt CLOCK}
     for consistency with the rest of the API.  One should also
     provide an interface involving the MAPL CFIO object.

#endif

!EOP

    character(len=*), parameter  :: Iam="MAPL_CFIOReadArray2D"
    integer                      :: STATUS

    type(ESMF_Field)             :: FIELD

    real    :: const = 0.0
    integer :: ios, k
    integer, allocatable    :: gridToFieldMap(:)
    integer                 :: gridRank

!                            ----


!   Special case: when filename is "/dev/null" it is assumed the user 
!   wants to set the variable to a constant
!   -----------------------------------------------------------------
    if ( FILETMPL(1:9) == '/dev/null' ) then    
         ios = -1
         k = index(FILETMPL,':')
         if ( k > 9 ) read(FILETMPL(k+1:),*,iostat=ios) const
         if ( ios /= 0 ) const = 0.0
         if ( MAPL_am_I_root() ) &
            print *, Iam // ': setting variable ' // trim(varn) // &
                            ' to constant = ', const
         RETURN_(ESMF_SUCCESS)
    end if

!   Create Field with input array
!   -----------------------------

    call ESMF_GridGet(GRID, dimCount=gridRank, rc=status)
    VERIFY_(STATUS)
    allocate(gridToFieldMap(gridRank), stat=status)
    VERIFY_(STATUS)
    if(gridRank == 2) then
       gridToFieldMap(1) = 1
       gridToFieldMap(2) = 2
    else if (gridRank == 3) then
       gridToFieldMap(1) = 1
       gridToFieldMap(2) = 2
       gridToFieldMap(3) = 0
    else
       RETURN_(ESMF_FAILURE)
    end if

    FIELD = ESMF_FieldCreate(grid=GRID, copyflag=ESMF_DATA_REF,   &
            farrayPtr=fARRAY, name=trim(varn), RC=STATUS)
    VERIFY_(STATUS)
   
    deallocate(gridToFieldMap)

!   Read array data from file
!   -------------------------
    call MAPL_CFIOReadField ( VARN, FILETMPL, TIME,       FIELD,          &
                              VERBOSE=VERBOSE, FORCE_REGRID=FORCE_REGRID, &
                              TIME_INTERP=TIME_INTERP,                    &
                              TIME_IS_CYCLIC=TIME_IS_CYCLIC, RC=STATUS    )
    VERIFY_(STATUS)

!   Destroy the ESMF array (data will be preserved since we own it)
!   --------------------------------------------------------------
    call ESMF_FieldDestroy ( FIELD, STATUS )
    VERIFY_(STATUS)

    RETURN_(ESMF_SUCCESS)

   end subroutine MAPL_CFIOReadArray2D

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!BOP
! !IROUTINE: MAPL_CFIODestroy --- Destroys MAPL CFIO Object

! !INTERFACE:
!
  subroutine MAPL_CFIODestroy( MCFIO, RC )
!
! !ARGUMENTS:
!
  type(MAPL_CFIO),             intent(INOUT) :: MCFIO
  integer, optional,           intent(  OUT) :: RC

! !DESCRIPTION: 
!
!    Destroys a MAPL CFIO object. It closes any file associated with
!    it and deallocates memory.

!EOP

  integer :: status
  character(len=*), parameter  :: Iam="MAPL_CFIODestroy"
  integer :: k

  if(associated(MCFIO%Krank     )) deallocate(MCFIO%Krank     )   
  if(associated(MCFIO%reqs      )) deallocate(MCFIO%reqs      )
  if(associated(MCFIO%varname   )) deallocate(MCFIO%varname   )
  if(associated(MCFIO%vardims   )) deallocate(MCFIO%vardims   )
  if(associated(MCFIO%Levs      )) deallocate(MCFIO%Levs      )

  nullify(MCFIO%Krank     )   
  nullify(MCFIO%reqs      )
  nullify(MCFIO%varname   )
  nullify(MCFIO%vardims   )
  nullify(MCFIO%Levs      )

  call MAPL_HorzTransformDestroy(MCFIO%Trans,rc=STATUS)
  VERIFY_(STATUS)

  if (MCFIO%myPE == MCFIO%Root) then
     call ESMF_CFIOFileClose(MCFIO%CFIO,rc=status)
     VERIFY_(STATUS)
  end if

  call ESMF_CFIODestroy(MCFIO%CFIO,rc=status)
  VERIFY_(STATUS)

  MCFIO%created = .false.

  RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_CFIODestroy


!BOP
! !IROUTINE: MAPL_CFIOClose --- Close file in MAPL CFIO Object

! !INTERFACE:
!
  subroutine MAPL_CFIOClose( MCFIO, RC )
!
! !ARGUMENTS:
!
  type(MAPL_CFIO),             intent(INOUT) :: MCFIO
  integer, optional,           intent(  OUT) :: RC

! !DESCRIPTION: 
!
!    Not a full destroy; only closes the file.

!EOP

  integer :: status
  character(len=*), parameter  :: Iam="MAPL_CFIOClose"

  if (MCFIO%myPE == MCFIO%Root) then
     call ESMF_CFIOFileClose(MCFIO%CFIO,rc=status)
     VERIFY_(STATUS)
  end if

  RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_CFIOClose



  subroutine MAPL_CFIOSet( MCFIO, Root, Psize, fName, RC )
!
! !ARGUMENTS:
!
  type(MAPL_CFIO),             intent(INOUT) :: MCFIO
  integer, optional,           intent(IN   ) :: Root, Psize
  character*(*), optional,     intent(IN   ) :: fName
  integer, optional,           intent(  OUT) :: RC

! !DESCRIPTION: 
!
!    Not a full destroy; only closes the file.

!EOP

  integer :: status
  character(len=*), parameter  :: Iam="MAPL_CFIOSet"

  if(present(Root)) then
     mCFIO%Root = Root
  endif

  if(present(Psize)) then
     mCFIO%Partsize = Psize
  endif

  if(present(fName)) then
     mCFIO%fName = fName
  endif

  RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_CFIOSet



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! This is a candidate for ESMFL, here for dependency reasons
!  

  subroutine GridGetLatLons_ ( grid, lons, lats, rc )

    implicit NONE
    type(ESMF_Grid) :: grid
    real, pointer   :: lons(:), lats(:)
    integer, optional :: rc

!                     ---

    character(len=*), parameter :: Iam = 'GridGetLatLons'

    real(KIND=8), pointer  :: R8D2(:,:)
    real, pointer          :: lons2d(:,:), lats2d(:,:)
    real, pointer          :: LONSLocal(:,:), LATSlocal(:,:)
    integer                :: IM_WORLD, JM_WORLD, dims(3), STATUS
    type(ESMF_DELayout )   :: layout
    type(ESMF_DistGrid )   :: distgrid

!                          ----

!      Get world dimensions
!      --------------------
       call MAPL_GridGet ( grid, globalCellCountPerDim=DIMS, RC=STATUS)
       VERIFY_(STATUS)

       IM_WORLD = dims(1)
       JM_WORLD = dims(2)

!      Allocate memory for output if necessary
!      ---------------------------------------
       if ( .not. associated(lons) ) then
            allocate(lons(IM_WORLD), stat=STATUS)
       else
            if(size(LONS,1) /= IM_WORLD) STATUS = 1
       end if
       VERIFY_(status)
       if ( .not. associated(lats) ) then
            allocate(lats(JM_WORLD), stat=STATUS)
       else
            if(size(LATS,1) /= JM_WORLD) STATUS = 1
       end if
       VERIFY_(status)

!      Local work space
!      ----------------
       allocate(LONS2d(IM_WORLD,JM_WORLD), LATS2d(IM_WORLD,JM_WORLD), &
                STAT=status)             
       VERIFY_(status)

!      Get the local longitudes and gather them into a global array
!      ------------------------------------------------------------

       call ESMF_GridGetCoord(grid, localDE=0, coordDim=1, &
            staggerloc=ESMF_STAGGERLOC_CENTER, &
            fptr=R8D2, doCopy=ESMF_DATA_REF, rc=status)
       VERIFY_(STATUS) 
       allocate(LONSLOCAL(size(R8D2,1),size(R8D2,2)),stat=status)
       VERIFY_(STATUS) 
       LONSLOCAL = R8D2*(180/MAPL_PI)
       call ArrayGather(LONSLOCAL, LONS2D, GRID, RC=STATUS)
       VERIFY_(STATUS) 
       DEALLOCATE(LONSlocal)

       call ESMF_GridGetCoord(grid, localDE=0, coordDim=2, &
            staggerloc=ESMF_STAGGERLOC_CENTER, &
            fptr=R8D2, doCopy=ESMF_DATA_REF, rc=status)
       VERIFY_(STATUS) 
       allocate(LATSLOCAL(size(R8D2,1),size(R8D2,2)),stat=status)
       VERIFY_(STATUS) 

       LATSLOCAL = R8D2*(180/MAPL_PI)
       call ArrayGather(LATSLOCAL, LATS2D, GRID, RC=STATUS)
       VERIFY_(STATUS)
       DEALLOCATE(LATSlocal)


       call ESMF_GridGet(GRID, DistGrid=distgrid, rc=status)
       VERIFY_(STATUS)
       call ESMF_DistGridGet(distgrid, DELayout=layout, rc=status)
       VERIFY_(STATUS)
       call MAPL_CommsBcast(layout, lons2d, size(lons2d), 0, rc = status)
       VERIFY_(STATUS)
       call MAPL_CommsBcast(layout, lats2d, size(lats2d), 0, rc = status)
       VERIFY_(STATUS)


!      Return 1D arrays
!      ----------------
       LONS = LONS2D(:,1)
       LATS = LATS2D(1,:)

       DEALLOCATE(LONS2d, LATS2d )
       
       RETURN_(ESMF_SUCCESS)
     end subroutine GridGetLatLons_

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! This is another candidate for ESMFL, here for dependency reasons
!  
!
! !IROUTINE: ESMFL_BundleAddState - Addes contents of State to Bundle
!
! !INTERFACE:
!
    RECURSIVE subroutine ESMFL_BundleAddState_ ( BUNDLE, STATE, rc, &
                                                 GRID, VALIDATE )
!
! !ARGUMENTS:
!
    implicit NONE
    type(ESMF_FieldBundle), intent(inout)         :: BUNDLE
    type(ESMF_State),  intent(INout)            :: STATE
    integer, optional                        :: rc
    type(ESMF_State),  optional, intent(in)  :: GRID
    logical, optional, intent(in)            :: VALIDATE
!
! !DESCRIPTION: Extracts fields from an ESMF State and adds them to a
!               ESMF Bundle. In essesence, it serializes an ESMF state
!  in a flat Bundle. The BUNDLE must have been created prior to calling 
!  this routine.
!
!EOP

    character(len=*), parameter          :: Iam="ESMFL_StateSerialize"
    integer                              :: STATUS

    type(ESMF_State)                     :: tSTATE
    type(ESMF_FieldBundle)                    :: tBUNDLE
    type(ESMF_Field)                     :: tFIELD
    type(ESMF_Grid)                      :: tGRID

    integer                              :: I, J
    integer                              :: ItemCount, FieldCount
    type (ESMF_StateItemType), pointer   :: ItemTypes(:)
    character(len=ESMF_MAXSTR ), pointer :: ItemNames(:), FieldNames(:)
    logical                              :: needGrid = .true.
    logical                              :: validate_ = .false.

!                           ---

    
    if ( present(validate) ) validate_ = validate

!   Query state for number of items and allocate space for them
!   -----------------------------------------------------------
    call ESMF_StateGet(STATE,ItemCount=ItemCount,RC=STATUS)
    VERIFY_(STATUS)
    ASSERT_(ItemCount>0)
    allocate ( ItemNames(ItemCount), stat=STATUS)
    VERIFY_(STATUS)
    allocate ( ItemTypes(ItemCount), stat=STATUS)
    VERIFY_(STATUS)

!   Next, retrieve the names and types of each item in the state
!   ------------------------------------------------------------
    call ESMF_StateGet ( STATE,      ItemNameList = ItemNames, &
                                StateItemtypeList = ItemTypes, &
                                rc=STATUS)
    VERIFY_(STATUS)

!   Loop over each item on STATE
!   ----------------------------
    do I = 1, ItemCount

!         Got a field
!         -----------
          if (ItemTypes(I) == ESMF_StateItem_Field) THEN

             call ESMF_StateGet ( STATE, ItemNames(i), tFIELD, rc=status)
             VERIFY_(STATUS)
             call AddThisField_()

!         Got a Bundle
!         ------------
          else if (ItemTypes(I) == ESMF_StateItem_FieldBundle) then

             call ESMF_StateGet(STATE, ItemNames(i), tBUNDLE, rc=STATUS)
             VERIFY_(STATUS)
             call ESMF_FieldBundleGet ( tBUNDLE, FieldCount = FieldCount, rc=STATUS)
             VERIFY_(STATUS)
             ASSERT_(FieldCount>0)
             do j = 1, FieldCount
                call ESMF_FieldBundleGet ( tBUNDLE, j, tFIELD, rc=STATUS)
                VERIFY_(STATUS)
                call AddThisField_()
             end do

!         Got another state
!         -----------------
          else if (ItemTypes(I) == ESMF_StateItem_State) then

             call ESMF_StateGet(STATE, ItemNames(i), tSTATE, rc=STATUS)
             VERIFY_(STATUS)
             call ESMFL_BundleAddState_ ( BUNDLE, tSTATE, rc=STATUS )
             VERIFY_(STATUS)

!         What is this?
!         ------------
          else

             STATUS = -1
             VERIFY_(STATUS)
           
          end IF

    end do

!   Make sure the Bundle is not empty
!   ---------------------------------
    call ESMF_FieldBundleGet ( BUNDLE, FieldCount = FieldCount, rc=STATUS)
    VERIFY_(STATUS)
    ASSERT_(FieldCount>0)

!   Set the grid
!   ------------
    if ( present(GRID) ) then
       call ESMF_FieldBundleSetGrid ( BUNDLE, tGRID, rc=STATUS )
       VERIFY_(STATUS)
    else if ( needGrid ) then
       STATUS = -1              ! could not find a Grid
       VERIFY_(STATUS)
    else
!ALT       call ESMF_FieldBundleSetGrid ( BUNDLE, tGRID, rc=STATUS )
       VERIFY_(STATUS)
    end if

!   Make sure field names are unique
!   --------------------------------
    allocate ( FieldNames(FieldCount), stat=STATUS )
    VERIFY_(STATUS) 
    call ESMF_FieldBundleGet ( BUNDLE, FieldNames, rc=STATUS )
    VERIFY_(STATUS) 

!   Make sure field names are unique
!   --------------------------------
    if ( validate_ ) then
       do j = 1, FieldCount
          do i = j+1, FieldCount
             if ( trim(FieldNames(i)) == trim(FieldNames(j)) ) then
                STATUS = -1              ! same name
                VERIFY_(STATUS)
             end if
          end do
       end do
    end if

!   All done
!   --------
    deallocate(ItemNames)
    deallocate(ItemTypes)
    deallocate(FieldNames)

    RETURN_(ESMF_SUCCESS)

CONTAINS

    subroutine AddThisField_()
      call ESMF_FieldBundleAdd ( BUNDLE, tFIELD, rc=STATUS )
      VERIFY_(STATUS)
      if ( needGrid ) then
         call ESMF_FieldGet ( tFIELD, grid=tGRID, rc=STATUS )
         VERIFY_(STATUS)
         needGrid = .false.
      end if
    end subroutine AddThisField_

  end subroutine ESMFL_BundleAddState_

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


  subroutine VertInterp(v2,v3,pp,ple_,pl_,rc)

    real,              intent(OUT) :: v2(:,:)
    real,              intent(IN ) :: v3(:,:,:)
    real,              intent(IN ) :: pp
    real,     target,  intent(IN ) :: ple_(:,:,:)
    real,     target,  intent(IN ) :: pl_(:,:,:)
    integer, optional, intent(OUT) :: rc

    real, dimension(size(v2,1),size(v2,2)) :: al,PT,PB
    integer km, K, msn
    logical flip
    real    ppx
    real, pointer   :: plx(:,:,:),pl(:,:,:),ps(:,:)

    integer        :: status
    character*(10) :: Iam='VertInterp'

    if(size(v3,3)==size(ple_,3)) then
       pl => ple_
       ps => ple_(:,:,ubound(ple_,3))
    else
       pl => pl_
       ps => null()
    endif

    km   = size(pl,3)

    flip = pl(1,1,km) < pl(1,1,km-1)

    if(flip) then
       allocate(plx(size(pl,1),size(pl,2),size(pl,3)),stat=status)
       VERIFY_(STATUS)
       plx = -pl
       ppx = -pp
       msn = -1
    else
       plx => pl
       ppx = pp
       msn = 1
    end if

    v2   = MAPL_UNDEF

       pb   = plx(:,:,km)
       do k=km-1,1,-1
          pt = plx(:,:,k)
          if(all(pb<ppx)) exit
          where(ppx>pt .and. ppx<=pb)
             al = (pb-ppx)/(pb-pt)
             v2 = v3(:,:,k)*al + v3(:,:,k+1)*(1.0-al)
          end where
          pb = pt
       end do

! Extend Lowest Level Value to the Surface
! ----------------------------------------
    if( associated(ps) ) then
        where( (ppx>plx(:,:,km).and.ppx<=ps*msn) )
                v2 = v3(:,:,km)
        end where
    end if

    if(flip) then
       deallocate(plx,stat=status)
       VERIFY_(STATUS)
    end if

    RETURN_(ESMF_SUCCESS)
  end subroutine VertInterp

  subroutine MAPL_GetCurrentFile(FileTmpl, Time, Filename, RC)
    character(len=*),    intent(IN   ) :: filetmpl
    type(ESMF_Time),     intent(INout) :: time
    character(len=*),    intent(  out) :: filename
    integer, optional,   intent(  out) :: rc

    integer :: status
    character(len=ESMF_MAXSTR), parameter:: IAm='MAPL_GetCurrentFile'

    character(len=ESMF_MAXSTR)          :: DATE
    integer                             :: nymd
    integer                             :: nhms

    call ESMF_TimeGet(Time, timeString=DATE, RC=STATUS)
    VERIFY_(STATUS)
    
    call strToInt(DATE, nymd, nhms)
    call ESMF_CFIOstrTemplate ( Filename, FileTmpl, 'GRADS', nymd=nymd, nhms=nhms, stat=status )
    VERIFY_(STATUS)
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_GetCurrentFile

  logical function MAPL_CFIOIsCreated(MCFIO)
    type(MAPL_CFIO),             intent(IN) :: MCFIO
    MAPL_CFIOIsCreated = MCFIO%Created
  end function MAPL_CFIOIsCreated

  character(len=ESMF_MAXSTR) function MAPL_CFIOGetFilename(MCFIO)
    type(MAPL_CFIO),             intent(IN) :: MCFIO
    MAPL_CFIOGetFilename = MCFIO%fNAME
  end function MAPL_CFIOGetFilename

end module MAPL_CFIOMod
